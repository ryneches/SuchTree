{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SuchTree Documentation","text":""},{"location":"#high-performance-sampling-of-very-large-trees","title":"High-performance sampling of very large trees","text":"<p>So, you have a phylogenetic tree, and you want to do some statistics with it. There are lots of packages in Python that let you manipulate phylogenies, like <code>dendropy</code>, the tree model included in <code>scikit-bio</code>, <code>ete3</code> and the awesome, shiny new <code>toytree</code>. For trees of modest size and statistical methods that don't require too many traversals, there a lot of great options. If you're working with about a thousand taxa or less, you should be able to use any of those packages for your tree.</p> <p>However, if you are working with trees that include tens of thousands, or perhaps millions of taxa, you will run into problems. <code>ete3</code>, <code>dendropy</code>, <code>toytree</code>, and<code>scikit-bio</code>'s <code>TreeNode</code> are all designed to give you lots of flexibility. You can re-root trees, use different traversal schemes, attach metadata to nodes, attach and detach nodes, splice sub-trees into or out of the main tree, plot trees for publication figures and do lots of other useful things. That power and flexibility comes with a price : speed.</p> <p>For trees of moderate size, it is sometimes possible to solve the speed issue by working with a matrix representation of the tree. Unfortunately, these representations scale quadratically with the number of taxa in the tree.  For example, the distance matrix for a tree of 100,000 taxa contains 10,000,000,000 elements, which will consume about 20GB of RAM. If your method performs sampling on this matrix then almost every operation will be a cache miss. Unless you are very clever about access patterns and matrix layout, the performance will be limited by RAM latency, leaving the CPU mostly idle. SuchTree is designed to solve this problem by representing trees as a highly compact object that usually fits into the CPU's L3 cache even for very large trees, and employs simple, assembly-language code paths for accessing data. Please see the Benchmarks for a more detailed look at performance.</p>"},{"location":"#sampling-linked-trees","title":"Sampling linked trees","text":"<p>Suppose you have more than one group of organisms, and you want to study the way their interactions have influenced their evolution. Now, you have several trees that link together to form a generalized graph.</p> <p><code>SuchLinkedTrees</code> has you covered. At the moment, <code>SuchLinkedTrees</code> supports trees of two interacting groups. Like <code>SuchTree</code>, <code>SuchLinkedTrees</code> is not intended to be a general-purpose graph theory package. Instead, it leverages <code>SuchTree</code> to efficiently handle the problem-specific tasks of working with co-phylogeny systems. It will load your datasets. It will build the graphs. It will let you subset the graphs using their phylogenetic or ecological properties. It will generate weighted adjacency and Laplacian matrixes of the whole graph or of subgraphs you have selected. It will generate spectral decompositions of subgraphs if spectral graph theory is your thing.</p> <p>And, if that doesn't solve your problem, it will emit sugraphs as <code>Graph</code> objects for use with the <code>igraph</code> network analysis package, or node and edge data for building graphs in  <code>networkx</code>. Now you can do even more things.  Maybe you want to get all crazy with some  graph kernels? Well, now you can.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>SuchTree</code> depends on the following packages :</p> <ul> <li><code>scipy</code></li> <li><code>numpy</code></li> <li><code>dendropy</code></li> <li><code>cython</code></li> <li><code>pandas</code></li> </ul> <p>To install the current release, you can install from PyPI :</p> <pre><code>pip install SuchTree\n</code></pre> <p>If you install using <code>pip</code>, binary packages (<code>wheels</code>) are available for CPython 3.9, 3.10 and 3.11, 3.12, 3.13 on Linux x86_64 and on MacOS with Intel and Apple silicon. If your platform isn't in that list, but it is supported by <code>cibuildwheel</code>, please file an issue to request your platform! I would be absolutely delighted to help you get <code>SuchTree</code> deployed on an exotic embedded system or a mainframe.</p> <p>To install the most recent development version :</p> <pre><code>git clone https://github.com/ryneches/SuchTree.git\ncd SuchTree\npip install -r requirements.txt\npip install .\n</code></pre> <p>To install via conda, first make sure you've got the bioconda channel set up, if you haven't already :</p> <pre><code>conda config --add channels bioconda\nconda config --add channels conda-forge\nconda config --set channel_priority strict\n</code></pre> <p>Then, install in the usual way :</p> <pre><code>conda install suchtree\n</code></pre> <p>Note that the conda package name is lower case!</p>"},{"location":"#basic-usage","title":"Basic usage","text":"<p><code>SuchTree</code> will accept URLs, file paths or valid NEWICK strings :</p> <pre><code>from SuchTree import SuchTree\n\nT = SuchTree( 'test.tree' )\nT = SuchTree( 'https://github.com/ryneches/SuchTree/blob/master/data/gopher-louse/gopher.tree' )\nT = SuchTree( '(A,B,(C,D));' )\n</code></pre> <p>If you are just starting out, begin with the Working Example. If you are interested in working with linked trees, you should start with the Linked Trees.</p> <p>For more, check out the API Documentation for how to use SuchTree, or the API Reference. The API Reference is generated automatically after each commit; it's guaranteed to be up-to-date, but not necessarily fun to read. </p> <p>I highly recommend using SuchTree with <code>toytree</code> for visualizing trees. Look for more convenient interoperation with <code>toytree</code> in future releases of SuchTree!</p>"},{"location":"#citing-suchtree","title":"Citing SuchTree","text":"<p>Please cite our 2018 paper in the Journal of Open Source Software :</p> <p>Russell Y. Neches, and Camille Scott. \"Suchtree: Fast, thread-safe computations with phylogenetic trees.\" Journal of Open Source Software 3, no. 26 (2018): 678.</p> <p>DOI : https://doi.org/10.21105/joss.00678</p>"},{"location":"#thanks","title":"Thanks","text":"<p>Special thanks to @camillescott and  @pmarkowsky for their many helpful suggestions (and for their patience).</p>"},{"location":"api/","title":"API Reference","text":"<p>This reference is automatically generated from the source code and docstrings using <code>mkdockstrings</code>. This page will always  be up to date to the latest git commit, but you may prefer documentation written by an actual human to be somewhat more palatable. </p> <p>Because <code>SuchTree</code> and <code>SuchLinkedTrees</code> are written in Cython and compiled into a shared library, the <code>mkdocstrings</code> is not (yet) able to extract the function implementations for documentation purposes. Sorry about that. You can always look in the source code.</p>"},{"location":"api/#suchtreesuchtree","title":"SuchTree.SuchTree","text":"<p>SuchTree extention type. The constructor accepts a filesystem path or URL to a file that describes the tree in NEWICK format. For now, SuchTree uses dendropy to parse the NEWICK file.</p> <p>An array of type Node is allocated, and freed when SuchTree.dealloc is invoked.</p> <p>Node.parent, Node.left_child and Node.right_child are integer offsets within this array, describing the tree structure. Nodes where left_child and right_child are -1 are leaf nodes, Nodes where the parent attribute is -1 are the root nodes (there should be only one of these in any given tree).</p> <p>SuchTree expects trees to be strictly bifrucating. There should not be any nodes that have only one child.</p> <p>SuchTrees are immutable; they cannot be modified once initialized. If you need to manipulate your tree before performing computations, you will need to use a different tool to perform those manipulations first.</p> <p>SuchTree constructor.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree-attributes","title":"Attributes","text":""},{"location":"api/#SuchTree.MuchTree.SuchTree.all_nodes","title":"<code>all_nodes</code>  <code>property</code>","text":"<p>Array of all node IDs in the tree.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.depth","title":"<code>depth</code>  <code>property</code>","text":"<p>The maximum depth of the tree.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.internal_nodes","title":"<code>internal_nodes</code>  <code>property</code>","text":"<p>Array of internal node IDs.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.leaf_names","title":"<code>leaf_names</code>  <code>property</code>","text":"<p>List of all leaf names.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.leaf_node_ids","title":"<code>leaf_node_ids</code>  <code>property</code>","text":"<p>Array of leaf node IDs.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.leaf_nodes","title":"<code>leaf_nodes</code>  <code>property</code>","text":"<p>Dictionary mapping leaf node IDs to names.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.leafnodes","title":"<code>leafnodes</code>  <code>property</code>","text":"<p>Deprecated : Use leaf_nodes instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.leafs","title":"<code>leafs</code>  <code>property</code>","text":"<p>Deprecated : Use leaves instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.leaves","title":"<code>leaves</code>  <code>property</code>","text":"<p>Dictionary mapping leaf names to node IDs.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.length","title":"<code>length</code>  <code>property</code>","text":"<p>Deprecated : Use size instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.n_leafs","title":"<code>n_leafs</code>  <code>property</code>","text":"<p>Deprecated : Use num_leaves instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.num_leaves","title":"<code>num_leaves</code>  <code>property</code>","text":"<p>The number of leaf nodes in the tree.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.polytomy_distance","title":"<code>polytomy_distance</code>  <code>property</code>","text":"<p>Deprecated : Use polytomy_epsilon instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.polytomy_epsilon","title":"<code>polytomy_epsilon</code>  <code>property</code>","text":"<p>Tiny, arbitrary, nonzero distance for polytomies.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.relative_evolutionary_divergence","title":"<code>relative_evolutionary_divergence</code>  <code>property</code>","text":"<p>The relative evolutionary divergence (RED) of the nodes in the tree. The RED of a node is the relative placement between the root and its descending tips (Parks et al. 2018). RED is defined to range from 0 at the root node to 1 at each leaf. Traversing the tree in pre-order, RED is P+(a/(a+b))*(1-P), where P is the RED of the node's parent, a is the distance to its parent, and b is the average distance from the node to its leaf descendants.</p> <p>RED is calculated for every node in the tree and returned as a dictionary. Once computed, the RED dictionary will be cached and made available as the SuchTree.RED attribute.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.root","title":"<code>root</code>  <code>property</code>","text":"<p>Deprecated : Use root_node instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.root_node","title":"<code>root_node</code>  <code>property</code>","text":"<p>The ID of the root node.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.size","title":"<code>size</code>  <code>property</code>","text":"<p>The number of nodes in the tree.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree-functions","title":"Functions","text":""},{"location":"api/#SuchTree.MuchTree.SuchTree.adjacency","title":"<code>adjacency(node: int = -1)</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use adjacency_matrix instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.adjacency_matrix","title":"<code>adjacency_matrix(from_node: Union[int, str] = None) -&gt; Dict[str, Any]</code>  <code>method descriptor</code>","text":"<p>Build the graph adjacency matrix of the tree or subtree.</p> <p>Renamed from adjacency().</p> <p>Args     from_node : Root node for subtree (default: tree root)</p> <p>Returns     Dict[ str, Any ] : Dictionary with keys:         - 'adjacency_matrix' : np.ndarray of edge weights         - 'node_ids'         : np.ndarray of corresponding node IDs</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.bipartition","title":"<code>bipartition(node: Union[int, str], by_id: bool = False) -&gt; frozenset</code>  <code>method descriptor</code>","text":"<p>Get the bipartition created by an internal node.</p> <p>Renamed from get_bipartition() for consistency.</p> <p>Args     node  : Internal node (ID or name)     by_id : If True, return node IDs; if False, return leaf names</p> <p>Returns     frozenset : Frozenset of two frozensets representing the bipartition</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds or is a leaf node</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.bipartitions","title":"<code>bipartitions(by_id: bool = False) -&gt; Generator[frozenset, None, None]</code>  <code>method descriptor</code>","text":"<p>Generate all bipartitions in the tree. Each bipartition is the pair of sets of leaf nodes partitioned by an internal node in the tree. </p> <p>Args     by_id : If True, yield node IDs; if False, yield leaf names</p> <p>Yields     frozenset : Bipartition as frozenset of two frozensets</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.common_ancestor","title":"<code>common_ancestor(a: Union[int, str], b: Union[int, str]) -&gt; int</code>  <code>method descriptor</code>","text":"<p>Find the most recent common ancestor of two nodes.</p> <p>Renamed from mrca().</p> <p>Args     a : First node (ID or name)     b : Second node (ID or name)</p> <p>Returns     int : Node ID of most recent common ancestor</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.degree_sequence","title":"<code>degree_sequence(from_node: Union[int, str] = None) -&gt; Dict[str, Any]</code>  <code>method descriptor</code>","text":"<p>Compute the degree sequence of the tree.</p> <p>Args     from_node : Root node for subtree (default: tree root)</p> <p>Returns     Dict[ str, Any ] : Dictionary with keys :         - 'degrees'    : np.ndarray of node degrees         - 'node_ids'   : np.ndarray of corresponding node IDs         - 'max_degree' : Maximum degree         - 'min_degree' : Minimum degree</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.distance","title":"<code>distance(a: Union[int, str], b: Union[int, str]) -&gt; float</code>  <code>method descriptor</code>","text":"<p>Calculate patristic distance between two nodes.</p> <p>Args     a : First node (ID or name)     b : Second node (ID or name)</p> <p>Returns     float : Patristic distance between the nodes</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.distance_matrix","title":"<code>distance_matrix(nodes: list = None) -&gt; Dict[str, Any]</code>  <code>method descriptor</code>","text":"<p>Build a distance matrix for specified nodes. Wraps pairwise_distances.</p> <p>Args     nodes : List of nodes (IDs or names). If None, uses all leaves.</p> <p>Returns     Dict[ str, Any ] : Dictionary with keys :         - 'distance_matrix' : np.ndarray of pairwise distances         - 'node_ids'        : np.ndarray of corresponding node IDs         - 'node_names'      : List of node names (if applicable)</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.distance_to_root","title":"<code>distance_to_root(node: Union[int, str]) -&gt; float</code>  <code>method descriptor</code>","text":"<p>Return distance from a node to the root.</p> <p>Renamed from get_distance_to_root() for consistency.</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     float : Distance to root node</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.distances","title":"<code>distances(pairs)</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use distances_bulk instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.distances_bulk","title":"<code>distances_bulk(pairs: ArrayLike) -&gt; np.ndarray</code>  <code>method descriptor</code>","text":"<p>Calculate distances for multiple node pairs efficiently.</p> <p>Renamed from distances() for clarity about bulk operation.</p> <p>Args     pairs : (n, 2) array of node ID pairs</p> <p>Returns     np.ndarray : Array of n distances</p> <p>Raises     ValueError       : If pairs array shape is incorrect     InvalidNodeError : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.distances_by_name","title":"<code>distances_by_name(pairs: List[Tuple[str, str]]) -&gt; List[float]</code>  <code>method descriptor</code>","text":"<p>Calculate distances for pairs of leaf names.</p> <p>Args     pairs : List of (leaf_name1, leaf_name2) tuples</p> <p>Returns     List[ float ] : List of patristic distances</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     TypeError         : If pairs is not a list of tuples</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.dump_array","title":"<code>dump_array()</code>  <code>method descriptor</code>","text":"<p>Print the whole tree. (WARNING : may be huge and useless.)</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.edges_data","title":"<code>edges_data()</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use to_networkx_edges instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_ancestors","title":"<code>get_ancestors(node: Union[int, str]) -&gt; Generator[int, None, None]</code>  <code>method descriptor</code>","text":"<p>Generator yielding ancestor node IDs from node to root.</p> <p>Renamed from get_lineage() for clarity.</p> <p>Args     node : Node ID or leaf name</p> <p>Yields     int : Ancestor node IDs in order from parent to root</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_bipartition","title":"<code>get_bipartition(node: Union[int, str], by_id: bool = False)</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use bipartition instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_children","title":"<code>get_children(node: Union[int, str]) -&gt; Tuple[int, int]</code>  <code>method descriptor</code>","text":"<p>Return the child node IDs for a given node.</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     Tuple[ int, int ] : Left and right child node IDs (child of leaf is -1)</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_descendant_nodes","title":"<code>get_descendant_nodes(node: Union[int, str])</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use get_descendants instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_descendants","title":"<code>get_descendants(node_id: int) -&gt; Generator[int, None, None]</code>  <code>method descriptor</code>","text":"<p>Generator yielding all descendant node IDs from a given node.</p> <p>Renamed from get_descendant_nodes() for consistency.</p> <p>Args     node_id : Node ID</p> <p>Yields     int : Descendant node IDs including the starting node</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_distance_to_root","title":"<code>get_distance_to_root(node: Union[int, str]) -&gt; float</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use distance_to_root instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_internal_nodes","title":"<code>get_internal_nodes(from_node=-1)</code>  <code>method descriptor</code>","text":"<p>Return an array of the ids of all internal nodes.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_leafs","title":"<code>get_leafs(node: Union[int, str])</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use get_leaves instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_leaves","title":"<code>get_leaves(node: Union[int, str]) -&gt; np.ndarray</code>  <code>method descriptor</code>","text":"<p>Return array of leaf node IDs descended from a given node.</p> <p>Renamed from get_leafs() with corrected pluralization.</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     np.ndarray : Array of leaf node IDs</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : I.f node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_lineage","title":"<code>get_lineage(node: Union[int, str])</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use get_ancestors instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_links","title":"<code>get_links(leaf_ids)</code>  <code>method descriptor</code>","text":"<p>Returns an array of column ids for an array of leaf ids.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_nodes","title":"<code>get_nodes(from_node=-1)</code>  <code>method descriptor</code>","text":"<p>Return an array of the ids of all nodes.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_parent","title":"<code>get_parent(node: Union[int, str]) -&gt; int</code>  <code>method descriptor</code>","text":"<p>Return the parent node ID for a given node.</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     int : Parent node ID (parent of root is -1)</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_quartet_topology","title":"<code>get_quartet_topology(a, b, c, d)</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use quartet_topology instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.get_support","title":"<code>get_support(node: Union[int, str]) -&gt; float</code>  <code>method descriptor</code>","text":"<p>Return the support value for a given node.</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     float : Support value (-1 if no support available)</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.has_children","title":"<code>has_children(node: Union[int, str]) -&gt; bool</code>  <code>method descriptor</code>","text":"<p>Test if a node has children (i.e., is not a leaf).</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     bool : True if node has children</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.has_parent","title":"<code>has_parent(node: Union[int, str]) -&gt; bool</code>  <code>method descriptor</code>","text":"<p>Test if a node has a parent (i.e., is not the root).</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     bool : True if node has a parent</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.in_order","title":"<code>in_order(distances: bool = True)</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use traverse_inorder instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.incidence_matrix","title":"<code>incidence_matrix(from_node: Union[int, str] = None) -&gt; Dict[str, Any]</code>  <code>method descriptor</code>","text":"<p>Build the incidence matrix of the tree or subtree.</p> <p>Args     from_node : Root node for subtree (default: tree root)</p> <p>Returns     Dict[ str, Any ] : Dictionary with keys :         - 'incidence_matrix' : np.ndarray where rows=nodes, cols=edges         - 'node_ids'         : np.ndarray of node IDs         - 'edge_list'        : List of (parent, child) tuples</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.is_ancestor","title":"<code>is_ancestor(ancestor: Union[int, str], descendant: Union[int, str]) -&gt; int</code>  <code>method descriptor</code>","text":"<p>Test ancestral relationship between two nodes.</p> <p>Args     ancestor   : Potential ancestor node (ID or name)     descendant : Potential descendant node (ID or name)</p> <p>Returns     int :  1 if ancestor is ancestor of descendant,           -1 if descendant is ancestor of ancestor,            0 if neither is ancestor of the other</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.is_descendant","title":"<code>is_descendant(descendant: Union[int, str], ancestor: Union[int, str]) -&gt; bool</code>  <code>method descriptor</code>","text":"<p>Test if descendant is a descendant of ancestor.</p> <p>New method for clarity - complements is_ancestor().</p> <p>Args     descendant : Potential descendant node (ID or name)     ancestor   : Potential ancestor node (ID or name)</p> <p>Returns     bool : True if descendant is a descendant of ancestor</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.is_internal","title":"<code>is_internal(node: Union[int, str]) -&gt; bool</code>  <code>method descriptor</code>","text":"<p>Test if a node is an internal node.</p> <p>Renamed from is_internal_node() for consistency.</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     bool : True if node is internal, False otherwise</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.is_internal_node","title":"<code>is_internal_node(node: Union[int, str]) -&gt; bool</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use is_internal instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.is_leaf","title":"<code>is_leaf(node: Union[int, str]) -&gt; bool</code>  <code>method descriptor</code>","text":"<p>Test if a node is a leaf node.</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     bool : True if node is a leaf, False otherwise</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.is_root","title":"<code>is_root(node: Union[int, str]) -&gt; bool</code>  <code>method descriptor</code>","text":"<p>Test if a node is the root node.</p> <p>Args     node : Node ID or leaf name</p> <p>Returns     bool : True if node is the root</p> <p>Raises     NodeNotFoundError : If leaf name is not found     InvalidNodeError  : If node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.is_sibling","title":"<code>is_sibling(node1: Union[int, str], node2: Union[int, str]) -&gt; bool</code>  <code>method descriptor</code>","text":"<p>Test if two nodes are siblings (share the same parent).</p> <p>Args     node1 : First node (ID or name)     node2 : Second node (ID or name)</p> <p>Returns     bool : True if nodes are siblings</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.laplacian","title":"<code>laplacian(node: int = -1)</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use laplacian_matrix instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.laplacian_matrix","title":"<code>laplacian_matrix(from_node: Union[int, str] = None) -&gt; Dict[str, Any]</code>  <code>method descriptor</code>","text":"<p>Build the graph Laplacian matrix of the tree or subtree.</p> <p>Renamed from laplacian().</p> <p>Args     from_node : Root node for subtree (default: tree root)</p> <p>Returns     Dict[ str, Any ] : Dictionary with keys:         - 'laplacian' : np.ndarray of Laplacian matrix         - 'node_ids'  : np.ndarray of corresponding node IDs</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.link_leaf","title":"<code>link_leaf(leaf_id, col_id)</code>  <code>method descriptor</code>","text":"<p>Attaches a leaf node to SuchLinkedTrees link matrix column.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.mrca","title":"<code>mrca(a: Union[int, str], b: Union[int, str]) -&gt; int</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use common_ancestor instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.nearest_neighbors","title":"<code>nearest_neighbors(node: Union[int, str], k: int = 1, from_nodes: List[Union[int, str]] = None) -&gt; List[Tuple[Union[int, str], float]]</code>  <code>method descriptor</code>","text":"<p>Find the k nearest neighbors to a given node.</p> <p>Args     node       : Query node (ID or name)     k          : Number of nearest neighbors to return     from_nodes : Nodes to search among (default: all leaves except query)</p> <p>Returns     List[ Tuple[ Union[ int, str ], float ] ] : List of (node, distance) pairs</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds     ValueError        : If k is not positive</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.nodes_data","title":"<code>nodes_data()</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use to_networkx_nodes instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.pairwise_distances","title":"<code>pairwise_distances(nodes: List[Union[int, str]] = None) -&gt; np.ndarray</code>  <code>method descriptor</code>","text":"<p>Calculate all pairwise distances between given nodes.</p> <p>Args     nodes : List of nodes (IDs or names). If None, uses all leaves.</p> <p>Returns     np.ndarray : Symmetric distance matrix</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.path_between_nodes","title":"<code>path_between_nodes(a: Union[int, str], b: Union[int, str]) -&gt; List[int]</code>  <code>method descriptor</code>","text":"<p>Find the path between two nodes through their common ancestor.</p> <p>New convenience method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Union[int, str]</code> <p>First node (ID or name)</p> required <code>b</code> <code>Union[int, str]</code> <p>Second node (ID or name)</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: List of node IDs forming the path from a to b</p> <p>Raises:</p> Type Description <code>NodeNotFoundError</code> <p>If any leaf name is not found</p> <code>InvalidNodeError</code> <p>If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.pre_order","title":"<code>pre_order()</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use traverse_preorder instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.quartet_topologies","title":"<code>quartet_topologies(quartets)</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use quartet_topologies_bulk instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.quartet_topologies_bulk","title":"<code>quartet_topologies_bulk(quartets: Union[list, np.ndarray]) -&gt; np.ndarray</code>  <code>method descriptor</code>","text":"<p>Bulk processing function for computing quartet topologies. Takes an [N,4] matrix of taxon IDs, where the IDs are in arbitrary order</p> <pre><code>[ [ a, b, c, d ], [ e, f, g, h ], ... ]\n</code></pre> <p>and returns an [N,4] matrix of taxon IDs ordered such that</p> <pre><code>[ { { a, b }, { c, d } }, { { e, f }, { g, h } }, ... ]\n</code></pre> <p>Ordered taxa can be represented as a topology like so :</p> <pre><code>topology = frozenset( ( frozenset( ( T[i,0], T[i,1] ),\n                        frozenset( ( T[i,2], T[i,3] ) ) ) ) )\n</code></pre> <p>Renamed from quartet_topologies() for clarity.</p> <p>Args     quartets : (n, 4) array of node IDs</p> <p>Returns     np.ndarray : (n, 4) array where each row contains ordered node IDs              representing the quartet topology</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If quartets array shape is incorrect</p> <code>InvalidNodeError</code> <p>If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.quartet_topologies_by_name","title":"<code>quartet_topologies_by_name(quartets: List[Tuple[str, str, str, str]]) -&gt; List[frozenset]</code>  <code>method descriptor</code>","text":"<p>Compute quartet topologies for quartets specified by leaf names.</p> <p>Args     quartets : List of tuples containing four leaf names each</p> <p>Returns     List[frozenset] : List of quartet topologies as frozensets</p> <p>Raises:</p> Type Description <code>NodeNotFoundError</code> <p>If any leaf name is not found</p> <code>TypeError</code> <p>If input format is incorrect</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.quartet_topology","title":"<code>quartet_topology(a: Union[int, str], b: Union[int, str], c: Union[int, str], d: Union[int, str]) -&gt; frozenset</code>  <code>method descriptor</code>","text":"<p>Determine the topology of a quartet of taxa.</p> <p>Renamed from get_quartet_topology() for consistency.</p> <p>Args     ( a, b ), ( c, d ) : Four nodes (IDs or names) forming the quartet</p> <p>Returns     frozenset : Topology as frozenset of two frozensets representing sister pairs</p> <p>Raises     NodeNotFoundError : If any leaf name is not found     InvalidNodeError  : If any node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.relationships","title":"<code>relationships()</code>  <code>method descriptor</code>","text":"<p>Deprecated : Use to_dataframe instead.</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.to_networkx_edges","title":"<code>to_networkx_edges(from_node: Union[int, str] = None) -&gt; Generator[Tuple[int, int, Dict[str, Any]], None, None]</code>  <code>method descriptor</code>","text":"<p>Generate edge data compatible with NetworkX.</p> <p>Renamed from edges_data().</p> <p>Args     from_node : Root node for subtree (default: tree root)</p> <p>Yields     Tuple[ int, int, Dict[ str, Any ] ] : tuples like ( child_id,                                                         parent_id,                                                         attributes_dict)</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.to_networkx_graph","title":"<code>to_networkx_graph(from_node: Union[int, str] = None)</code>  <code>method descriptor</code>","text":"<p>Create a NetworkX Graph object from the tree.</p> <p>Args     from_node : Root node for subtree (default: tree root)</p> <p>Returns     networkx.Graph : NetworkX graph representation</p> <p>Raises     ImportError       : If NetworkX is not installed     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.to_networkx_nodes","title":"<code>to_networkx_nodes(from_node: Union[int, str] = None) -&gt; Generator[Tuple[int, Dict[str, Any]], None, None]</code>  <code>method descriptor</code>","text":"<p>Generate node data compatible with NetworkX.</p> <p>Renamed from nodes_data().</p> <p>Args     from_node : Root node for subtree (default: tree root)</p> <p>Yields     Tuple[ int, Dict[ str, Any ] ] : ( node_id, attributes_dict) pairs</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.to_newick","title":"<code>to_newick(from_node: Union[int, str] = None, include_support: bool = True, include_distances: bool = True) -&gt; str</code>  <code>method descriptor</code>","text":"<p>Export tree or subtree to Newick format.</p> <p>Args     from_node         : Root node for subtree (default: tree root)     include_support   : Include support values in output     include_distances : Include branch lengths in output</p> <p>Returns     str : Newick format string</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.traverse_inorder","title":"<code>traverse_inorder(include_distances: bool = True) -&gt; Generator[Union[int, Tuple[int, float]], None, None]</code>  <code>method descriptor</code>","text":"<p>Traverse the tree in inorder (left, root, right).</p> <p>Renamed from in_order().</p> <p>Args     include_distances : If True, yield (node_id, distance_to_parent) tuples                         If False, yield only node_ids</p> <p>Yields     Union[ int, Tuple[ int, float ] ] : Node ID or (node_id, distance) tuple</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.traverse_internal_only","title":"<code>traverse_internal_only(from_node: Union[int, str] = None) -&gt; Generator[int, None, None]</code>  <code>method descriptor</code>","text":"<p>Traverse only the internal nodes.</p> <p>Args     from_node : Starting node (default: root)</p> <p>Yields     int : Internal node IDs</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.traverse_leaves_only","title":"<code>traverse_leaves_only(from_node: Union[int, str] = None) -&gt; Generator[int, None, None]</code>  <code>method descriptor</code>","text":"<p>Traverse only the leaf nodes.</p> <p>Args     from_node : Starting node (default: root)</p> <p>Yields     int : Leaf node IDs</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.traverse_levelorder","title":"<code>traverse_levelorder(from_node: Union[int, str] = None) -&gt; Generator[int, None, None]</code>  <code>method descriptor</code>","text":"<p>Traverse the tree level by level (breadth-first).</p> <p>Args     from_node : Starting node (default: root)</p> <p>Yields     int : Node IDs in level order traversal</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.traverse_postorder","title":"<code>traverse_postorder(from_node: Union[int, str] = None) -&gt; Generator[int, None, None]</code>  <code>method descriptor</code>","text":"<p>Traverse the tree in postorder (left, right, root).</p> <p>Args     from_node : Starting node (default: root)</p> <p>Yields     int : Node IDs in postorder traversal</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.traverse_preorder","title":"<code>traverse_preorder(from_node: Union[int, str] = None) -&gt; Generator[int, None, None]</code>  <code>method descriptor</code>","text":"<p>Traverse the tree in preorder (root, left, right).</p> <p>Renamed from pre_order(), plus new from_node parameter.</p> <p>Args     from_node : Starting node (default: root)</p> <p>Yields     int : Node IDs in preorder traversal</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.traverse_with_depth","title":"<code>traverse_with_depth(from_node: Union[int, str] = None) -&gt; Generator[Tuple[int, int], None, None]</code>  <code>method descriptor</code>","text":"<p>Traverse the tree with depth information.</p> <p>Args     from_node : Starting node (default: root)</p> <p>Yields     Tuple[int, int] : (node_id, depth) pairs</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#SuchTree.MuchTree.SuchTree.traverse_with_distances","title":"<code>traverse_with_distances(from_node: Union[int, str] = None) -&gt; Generator[Tuple[int, float, float], None, None]</code>  <code>method descriptor</code>","text":"<p>Traverse the tree with distance information.</p> <p>Args     from_node : Starting node (default: root)</p> <p>Yields     Tuple[ int, float, float ] : tuples ( node_id,                                            distance_to_parent,                                            distance_to_root)</p> <p>Raises     NodeNotFoundError : If from_node leaf name is not found     InvalidNodeError  : If from_node ID is out of bounds</p>"},{"location":"api/#suchtreesuchlinkedtrees","title":"SuchTree.SuchLinkedTrees","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees-attributes","title":"Attributes","text":""},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.TreeA","title":"<code>TreeA</code>  <code>property</code>","text":"<p>first tree initialized by SuchLinkedTrees( TreeA, TreeB )</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.TreeB","title":"<code>TreeB</code>  <code>property</code>","text":"<p>second tree initialized by SuchLinkedTrees( TreeA, TreeB )</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.col_ids","title":"<code>col_ids</code>  <code>property</code>","text":"<p>ids of the columns (TreeB) in the link matrix.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.col_names","title":"<code>col_names</code>  <code>property</code>","text":"<p>Names of the columns (TreeB) in the link matrix.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.linklist","title":"<code>linklist</code>  <code>property</code>","text":"<p>numpy representation of link list</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.linkmatrix","title":"<code>linkmatrix</code>  <code>property</code>","text":"<p>numpy representation of link matrix (generated only on access)</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.n_cols","title":"<code>n_cols</code>  <code>property</code>","text":"<p>Number of columns in the link matrix.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.n_links","title":"<code>n_links</code>  <code>property</code>","text":"<p>size of the link list</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.n_rows","title":"<code>n_rows</code>  <code>property</code>","text":"<p>Number of rows in the link matrix.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.row_ids","title":"<code>row_ids</code>  <code>property</code>","text":"<p>ids of the rows (TreeA) in the link matrix.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.row_names","title":"<code>row_names</code>  <code>property</code>","text":"<p>Names of the rows (TreeA) in the link matrix.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_a_leafs","title":"<code>subset_a_leafs</code>  <code>property</code>","text":"<p>ids of the current subset rows.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_a_root","title":"<code>subset_a_root</code>  <code>property</code>","text":"<p>ID of the current subset root in TreeA.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_a_size","title":"<code>subset_a_size</code>  <code>property</code>","text":"<p>Number of rows in the current subset.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_b_leafs","title":"<code>subset_b_leafs</code>  <code>property</code>","text":"<p>ids of the current subset columns.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_b_root","title":"<code>subset_b_root</code>  <code>property</code>","text":"<p>ID of the current subset root in TreeB.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_b_size","title":"<code>subset_b_size</code>  <code>property</code>","text":"<p>Number of columns in the current subset.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_columns","title":"<code>subset_columns</code>  <code>property</code>","text":"<p>ids of the current subset columns.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_n_links","title":"<code>subset_n_links</code>  <code>property</code>","text":"<p>Number of links in the current subset.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees-functions","title":"Functions","text":""},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.adjacency","title":"<code>adjacency(deletions=0, additions=0, swaps=0)</code>  <code>method descriptor</code>","text":"<p>Build the graph adjacency matrix of the current subsetted trees, applying the specified random permutaitons.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.dump_table","title":"<code>dump_table()</code>  <code>method descriptor</code>","text":"<p>Print the link matrix (WARNING : may be huge and useless)</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.laplacian","title":"<code>laplacian(deletions=0, additions=0, swaps=0)</code>  <code>method descriptor</code>","text":"<p>The graph Laplacian matrix of the current subsetted trees.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.linked_distances","title":"<code>linked_distances()</code>  <code>method descriptor</code>","text":"<p>Compute distances for all pairs of links. For large link tables, this will fail on memory allocation.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.spectrum","title":"<code>spectrum(deletions=0, additions=0, swaps=0)</code>  <code>method descriptor</code>","text":"<p>The eigenvalues of the graph Laplacian matrix of the current subsetted trees.</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_a","title":"<code>subset_a(node_id)</code>  <code>method descriptor</code>","text":"<p>subset the link matrix to leafs desended from node_id in TreeA</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.subset_b","title":"<code>subset_b(node_id)</code>  <code>method descriptor</code>","text":"<p>subset the link matrix to leafs desended from node_id in TreeB</p>"},{"location":"api/#SuchTree.MuchTree.SuchLinkedTrees.to_igraph","title":"<code>to_igraph(deletions=0, additions=0, swaps=0)</code>  <code>method descriptor</code>","text":"<p>Return the current SuchLinkedTrees subgraph as a weighted, labled igraph object. The igraph package must be installed.</p>"},{"location":"api/#SuchTree.exceptions","title":"<code>SuchTree.exceptions</code>","text":""},{"location":"api/#SuchTree.exceptions.SuchTreeError","title":"<code>SuchTreeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class errors.</p>"},{"location":"api/#SuchTree.exceptions.NodeNotFoundError","title":"<code>NodeNotFoundError(node, message=None)</code>","text":"<p>               Bases: <code>SuchTreeError</code></p> <p>Raised when a node ID or leaf name is not found in the tree.</p> Source code in <code>SuchTree/exceptions.py</code> <pre><code>def __init__( self, node, message=None ):\n    if message is None :\n        if isinstance( node, str ) :\n            message = 'Leaf name not found: {node}.'.format( node=str(node) )\n        else :\n            message = 'Node not found: {node}'.format( node=str(node) )\n    super().__init__( message )\n    self.node = node\n</code></pre>"},{"location":"api/#SuchTree.exceptions.InvalidNodeError","title":"<code>InvalidNodeError(node_id, tree_size=None, message=None)</code>","text":"<p>               Bases: <code>SuchTreeError</code></p> <p>Raised when a node ID is out of bounds or invalid.</p> Source code in <code>SuchTree/exceptions.py</code> <pre><code>def __init__( self,\n              node_id,\n              tree_size=None,\n              message=None ) :\n    if message is None :\n        if tree_size is not None :\n            message = 'Node ID {node_id} out of bounds (tree size: {tree_size})'.format( node_id=str(node_id),\n                                                                                         tree_size=str(tree_size) )\n        else :\n            message = 'Invalid node ID: {node_id}'.format( node_id=str(node_id) )\n    super().__init__( message )\n    self.node_id = node_id\n    self.tree_size = tree_size\n</code></pre>"},{"location":"api/#SuchTree.exceptions.TreeStructureError","title":"<code>TreeStructureError</code>","text":"<p>               Bases: <code>SuchTreeError</code></p> <p>Raised when tree structure is invalid or inconsistent.</p>"},{"location":"api_docs/","title":"SuchTree Class API Reference","text":""},{"location":"api_docs/#overview","title":"Overview","text":"<p>The <code>SuchTree</code> class provides high-performance phylogenetic tree manipulation using Cython. It supports: - Fast tree traversal and node queries - Patristic distance calculations - Topological analysis - Multiple tree formats (Newick, URL, file path) - Integration with NetworkX and igraph</p> <p>Some best practices to keep in mind :</p> <ol> <li>Use node IDs for performance-critical code</li> <li>Prefer bulk methods (<code>distances_bulk</code>) for multiple calculations</li> <li>Cache frequently-used properties (like RED values)</li> <li>Use traversal generators for memory efficiency</li> </ol> <p>The supporting <code>SuchLinkedTrees</code> class provides several useful bookkeeping features for working with co-phylogeny datasets, most importantly the ability to perform reciprocal masking of one tree by  clades in its linked tree. Subset masking is thread-safe, fast and non-destructive. However, please note that SuchTree 1.3 is the last release that will include this interface for SuchLinkedTrees. The next major release will include a modernized, multi-tree container with a new interface.</p>"},{"location":"api_docs/#initialization","title":"Initialization","text":"<p><pre><code>class SuchTree(tree_input: Union[str, Path])\n</code></pre> Construct from: - Newick string - File path - URL (http/https/ftp)</p> <p>Example: <pre><code>tree = SuchTree(\"(A:0.1,B:0.2,(C:0.3,D:0.4));\")\ntree = SuchTree(\"https://example.com/tree.newick\")\n</code></pre></p>"},{"location":"api_docs/#core-properties","title":"Core Properties","text":""},{"location":"api_docs/#tree-structure","title":"Tree Structure","text":"Property Type Description Example <code>size</code> <code>int</code> Total nodes <code>tree.size</code> \u2192 7 <code>depth</code> <code>int</code> Max depth <code>tree.depth</code> \u2192 3 <code>num_leaves</code> <code>int</code> Leaf count <code>tree.num_leaves</code> \u2192 4 <code>root_node</code> <code>int</code> Root ID <code>tree.root_node</code> \u2192 0 <code>polytomy_epsilon</code> <code>float</code> Polytomy resolution <code>1e-20</code>"},{"location":"api_docs/#node-collections","title":"Node Collections","text":"Property Type Description Contains <code>leaves</code> <code>Dict[str, int]</code> Name \u2192 ID <code>{'A': 1, 'B': 2}</code> <code>leaf_nodes</code> <code>Dict[int, str]</code> ID \u2192 Name <code>{1: 'A', 2: 'B'}</code> <code>internal_nodes</code> <code>np.ndarray</code> Internal IDs <code>[0, 3, 4]</code> <code>all_nodes</code> <code>np.ndarray</code> All IDs <code>[0, 1, 2, 3, 4, 5, 6]</code> <code>leaf_node_ids</code> <code>np.ndarray</code> Leaf IDs <code>[1, 2, 5, 6]</code> <code>leaf_names</code> <code>list</code> Leaf names <code>['A', 'B', 'C', 'D']</code>"},{"location":"api_docs/#example-usage","title":"Example Usage","text":"<p>Here are some examples of operations you can do with SuchTree.</p> <pre><code># Initialize a tree and print some basic properties\ntree = SuchTree(\"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;\")\nprint(f\"Tree depth: {tree.depth}\")\nprint(f\"Leaf names: {tree.leaf_names}\")\n\n# Find some node relationships\nnode_id = tree.leaves['A']\nparent_id = tree.get_parent(node_id)\nchildren = tree.get_children(parent_id)\n\n# Distance analysis\ndist = tree.distance('A', 'C')\ndist_matrix = tree.pairwise_distances(['A', 'B', 'C', 'D'])\n\n# Calculate RED values\nred_values = tree.relative_evolutionary_divergence()\n\n# Export tree as a networkx graph (requires networkx)\nnx_graph = tree.to_networkx_graph()\n</code></pre>"},{"location":"api_docs/#error-handling","title":"Error Handling","text":"<ul> <li><code>NodeNotFoundError</code>  : Invalid leaf name</li> <li><code>InvalidNodeError</code>   : Invalid node ID</li> <li><code>TreeStructureError</code> : Invalid tree operations</li> <li><code>ValueError</code>         : Invalid input format</li> <li><code>TypeError</code>          : Incorrect argument type</li> </ul>"},{"location":"api_docs/#core-methods","title":"Core Methods","text":""},{"location":"api_docs/#node-relationships","title":"Node Relationships","text":"<p><pre><code>get_parent(node: Union[int, str]) -&gt; int\n</code></pre> Get immediate parent node for a given node.</p> <p>Args:     node: Node identifier as either integer ID or leaf name string</p> <p>Returns:     Integer ID of parent node. Returns -1 if called on root node.</p> <p>Raises:     NodeNotFoundError: If leaf name doesn't exist in the tree     InvalidNodeError: If node ID is out of valid range (0 &lt;= id &lt; tree.size)</p> <p>Example: <pre><code>parent_id = tree.get_parent(\"A\")\nparent_id = tree.get_parent(5)\n</code></pre></p> <p><pre><code>get_children(node: Union[int, str]) -&gt; Tuple[int, int]\n</code></pre> Get direct children of a node. </p> <p>Args:     node: Node identifier as either integer ID or leaf name string</p> <p>Returns:     Tuple of (left_child, right_child) node IDs. Returns (-1, -1) for leaf nodes.</p> <p>Raises:     NodeNotFoundError: If leaf name doesn't exist     InvalidNodeError: If node ID is invalid</p> <p>Note:     For multifurcating trees, only the first two children are returned. Use      <code>traverse_children()</code> method for complete child iteration.</p> <p><pre><code>get_ancestors(node: Union[int, str]) -&gt; Generator[int, None, None]\n</code></pre> Generate ancestor node IDs from node to root. Yields parent IDs in ascending order from immediate parent to root.</p> <p><pre><code>get_descendants(node_id: int) -&gt; Generator[int, None, None]\n</code></pre> Generate all descendant node IDs in depth-first order. Includes the starting node in the output.</p> <p><pre><code>get_leaves(node: Union[int, str]) -&gt; np.ndarray\n</code></pre> Get array of leaf node IDs descended from a given node. Uses efficient buffer reuse for performance.</p> <p><pre><code>get_support(node: Union[int, str]) -&gt; float\n</code></pre> Retrieve node support value. Returns -1 if no support available. Works for both internal nodes and leaves.</p>"},{"location":"api_docs/#tree-navigation","title":"Tree Navigation","text":"<p><pre><code>is_leaf(node: Union[int, str]) -&gt; bool\n</code></pre> Check if node is a leaf. Uses optimized Cython implementation for fast checking.</p> <p><pre><code>is_internal(node: Union[int, str]) -&gt; bool\n</code></pre> Check if node is internal. Simply returns negation of <code>is_leaf</code> but provides clearer intent.</p> <p><pre><code>is_ancestor(ancestor: Union[int, str], descendant: Union[int, str]) -&gt; int\n</code></pre> Test ancestral relationship. Returns:</p> <ul> <li><code>1</code> if ancestor of descendant </li> <li><code>-1</code> if descendant is ancestor </li> <li><code>0</code> if no direct relationship</li> </ul> <p><pre><code>is_descendant(descendant: Union[int, str], ancestor: Union[int, str]) -&gt; bool\n</code></pre> Convenience method that returns True if descendant is indeed a descendant of ancestor.</p> <p><pre><code>is_root(node: Union[int, str]) -&gt; bool\n</code></pre> Check if node is the tree root. Uses direct comparison with stored root node ID.</p> <p><pre><code>is_sibling(node1: Union[int, str], node2: Union[int, str]) -&gt; bool\n</code></pre> Check if two nodes share the same parent. Automatically returns False if either node is root.</p> <p><pre><code>has_children(node: Union[int, str]) -&gt; bool\n</code></pre> Determine if node has any children. Equivalent to <code>is_internal</code> but may be more intuitive for some users.</p> <p><pre><code>has_parent(node: Union[int, str]) -&gt; bool\n</code></pre> Check if node has a parent (i.e., is not root). Returns negation of <code>is_root</code>.</p> <p><pre><code>common_ancestor(a: Union[int, str], b: Union[int, str]) -&gt; int\n</code></pre> Find most recent common ancestor of two nodes. Uses optimized MRCA algorithm with visited node tracking.</p> <p><pre><code>path_between_nodes(a: Union[int, str], b: Union[int, str]) -&gt; List[int]\n</code></pre> Get node IDs forming the path between two nodes through their common ancestor. Returns list from a -&gt; MRCA -&gt; b.</p>"},{"location":"api_docs/#distance-analysis","title":"Distance Analysis","text":"<p>SuchTree was originally built to compute patristic (leaf-to-leaf) distances as efficiently as possible. You have two choices to make :</p> <ul> <li>Do you want to use leaf names or leaf IDs?</li> <li>Do you want to to calculate distances for single a pair of leafs, or a table of leaf pairs?</li> </ul> <p>It is important to remember that even if you have two trees with exactly the same leaf names, the leafs will have different node IDs if the topologies are different. For those cases, it is better to use use the leaf name to ID mappings (<code>SuchTree.leaves</code> and <code>SuchTree.leaf_nodes</code>) to associate your leaf nodes with other data.</p> <p><pre><code>distance(a: Union[int, str], b: Union[int, str]) -&gt; float\n</code></pre> Calculate patristic distance between two nodes along the tree.</p> <p>Args:     a: First node identifier (ID or name)     b: Second node identifier (ID or name)</p> <p>Returns:     Sum of branch lengths along the path between nodes via their most recent      common ancestor (MRCA)</p> <p>Raises:     NodeNotFoundError: If either node name doesn't exist     InvalidNodeError: If either node ID is invalid</p> <p>Complexity:     O(h) where h is the height of the tree. Uses cached ancestor paths for     optimal performance.</p> <p>Example: <pre><code>dist = tree.distance(\"A\", \"B\")\ndist = tree.distance(2, 5)\n</code></pre></p> <p><pre><code>distances_bulk(pairs: np.ndarray) -&gt; np.ndarray\n</code></pre> Efficiently compute distances for multiple node pairs. Accepts (n, 2) array of node IDs. Uses Cython nogil implementation.</p> <p><pre><code>distances_by_name(pairs: List[Tuple[str, str]]) -&gt; List[float]\n</code></pre> Convenience wrapper for bulk distance calculation using leaf names instead of IDs.</p> <p><pre><code>pairwise_distances(nodes: list = None) -&gt; np.ndarray\n</code></pre> Generate full distance matrix for specified nodes (all leaves by default). Returns symmetric numpy array.</p> <p><pre><code>distance_to_root(node: Union[int, str]) -&gt; float\n</code></pre> Calculate total branch length from node to root. Optimized with cumulative distance caching.</p> <p><pre><code>nearest_neighbors(node: Union[int, str], k=1) -&gt; List[Tuple[Union[int, str], float]]\n</code></pre> Find k nearest neighbors to a node. Can search among specific nodes or all leaves by default.</p>"},{"location":"api_docs/#tree-traversal","title":"Tree Traversal","text":"<p>SuchTree includes a collection of generators for traversing the tree in different ways. They all work the same way, other than the different order of traversal.</p> <p><pre><code>traverse_inorder(include_distances: bool = True) -&gt; Generator\n</code></pre> In-order traversal (left, root, right). Yields node IDs or (ID, distance) tuples.</p> <pre><code>traverse_preorder(from_node: Union[int, str] = None) -&gt; Generator\n\"\"\"\nIterate through nodes in pre-order traversal (parent before children).\n\nArgs:\n    from_node: Starting node (default: root). Can be ID or name.\n\nYields:\n    Node IDs in traversal order\n\nRaises:\n    NodeNotFoundError: If from_node name doesn't exist\n    InvalidNodeError: If from_node ID is invalid\n\nMemory:\n    O(h) space complexity due to stack implementation, where h is tree height\n\nExample:\n```python\nfor node_id in tree.traverse_preorder():\n    print(f\"Visiting node {node_id}\")\n</code></pre> <p><pre><code>traverse_postorder(from_node: Union[int, str] = None) -&gt; Generator\n</code></pre> Post-order traversal (left, right, root). Useful for dependency resolution.</p> <p><pre><code>traverse_levelorder(from_node: Union[int, str] = None) -&gt; Generator\n</code></pre> Breadth-first level order traversal. Yields nodes by depth level.</p> <p><pre><code>traverse_leaves_only(from_node: Union[int, str] = None) -&gt; Generator\n</code></pre> Efficient traversal that only yields leaf nodes. Skips internal nodes.</p> <p><pre><code>traverse_internal_only(from_node: Union[int, str] = None) -&gt; Generator\n</code></pre> Traversal that skips leaf nodes. Useful for operations only on internal nodes.</p> <p><pre><code>traverse_with_depth(from_node: Union[int, str] = None) -&gt; Generator[Tuple[int, int], None, None]\n</code></pre> Traversal yielding (node ID, depth) pairs. Depth starts at 0 for root.</p> <p><pre><code>traverse_with_distances(from_node: Union[int, str] = None) -&gt; Generator[Tuple[int, float, float], None, None]\n</code></pre> Traversal yielding (node ID, distance to parent, cumulative distance to root).</p>"},{"location":"api_docs/#topological-analysis","title":"Topological Analysis","text":"<pre><code>bipartition(node: Union[int, str], by_id=False) -&gt; frozenset\nbipartitions(by_id=False) -&gt; Generator[frozenset, None, None]\nquartet_topology(a: Union[int, str], b: Union[int, str], c: Union[int, str], d: Union[int, str]) -&gt; frozenset\nquartet_topologies_bulk(quartets: Union[list, np.ndarray]) -&gt; np.ndarray\nquartet_topologies_by_name(quartets: List[Tuple[str, str, str, str]]) -&gt; List[frozenset]\n</code></pre>"},{"location":"api_docs/#graph-operations","title":"Graph Operations","text":"<pre><code>adjacency_matrix(from_node: Union[int, str] = None) -&gt; Dict[str, Any]\nlaplacian_matrix(from_node: Union[int, str] = None) -&gt; Dict[str, Any]\nincidence_matrix(from_node: Union[int, str] = None) -&gt; Dict[str, Any]\ndegree_sequence(from_node: Union[int, str] = None) -&gt; Dict[str, Any]\n</code></pre>"},{"location":"api_docs/#export-conversion","title":"Export &amp; Conversion","text":"<pre><code>to_networkx_graph(from_node: Union[int, str] = None) -&gt; 'networkx.Graph'\nto_newick(include_support=True, include_distances=True) -&gt; str\nrelative_evolutionary_divergence() -&gt; Dict[int, float]\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#benchmarks","title":"Benchmarks","text":"<p><code>SuchTree</code> is motivated by the observation that the memory usage of distance matrixes grows quadratically with taxa, while for trees it grows linearly. A matrix of 100,000 taxa is quite bulky, but the tree it represents can be made to fit into about 7.6MB of RAM if implemented using only <code>C</code> primitives. This is small enough to fit into L2 cache on many modern microprocessors. This comes at the cost of traversing the tree for every calculation (about 16 hops from leaf to root for a 100,000 taxa tree), but, as these operations all happen on-chip, the processor can take full advantage of pipelining, speculative execution and other optimizations available in modern CPUs. And, because <code>SuchTree</code> objects are immutable, they are thread-safe. You can take full advantage of modern multicore chips.</p> <p>Here, we use <code>SuchTree</code> to compare the topology of two trees built from the same 54,327 sequences using two methods : neighbor joining and Morgan Price's <code>FastTree</code> approximate maximum likelihood algorithm. Using one million randomly chosen pairs of leaf nodes, we look at the patristic distances in each of the two trees, plot them against one another, and compute correlation coefficients.</p> <p>On an Intel i7-3770S, <code>SuchTree</code> completes the two million distance calculations in a little more than ten seconds.</p> <pre><code>from SuchTree import SuchTree\nimport random\n\nT1 = SuchTree( 'data/bigtrees/ml.tree' )\nT2 = SuchTree( 'data/bigtrees/nj.tree' )\n\nprint( 'nodes : %d, leafs : %d' % ( T1.length, len(T1.leafs) ) )\nprint( 'nodes : %d, leafs : %d' % ( T2.length, len(T2.leafs) ) )\n</code></pre> <pre><code>nodes : 108653, leafs : 54327\nnodes : 108653, leafs : 54327\n</code></pre> <pre><code>N = 1000000\nv = list( T1.leafs.keys() )\n\npairs = []\nfor i in range(N) :\n    pairs.append( ( random.choice( v ), random.choice( v ) ) )\n\n%time D1 = T1.distances_by_name( pairs ); D2 = T2.distances_by_name( pairs )\n</code></pre> <pre><code>CPU times: user 10.1 s, sys: 0 ns, total: 10.1 s\nWall time: 10.1 s\n</code></pre> <p></p> <p><pre><code>from scipy.stats import kendalltau, pearsonr\n\nprint( 'Kendall\\'s tau : %0.3f' % kendalltau( D1, D2 )[0] )\nprint( 'Pearson\\'s r   : %0.3f' % pearsonr( D1, D2 )[0] )\n</code></pre> <pre><code>Kendall's tau : 0.709\nPearson's r   : 0.969\n</code></pre></p>"},{"location":"datasets/","title":"Example datasets","text":"<p>For analysis of ecological interactions, <code>SuchTree</code> is distributed with a curated collection of several different co-phylogenetic relationships gathered from the literature. Additionally, a collection of simulated interactions with various properties, along with an annotated notebook for generating them, is also included. Interactions are registered in a JSON object (<code>data/studies.json</code>).</p> <p>For convenience, I've given each dataset a short name (e.g., 'gopher-louse') suitable for labeling in plots.</p> <p>If you are aware of any publications with this type of data, please let me know! A pull request would be the ideal way to make sure you get some credit for telling me about it, but an email or a message on social media would be perfectly fine.</p> <p>If you use any of these datasets in your work, please cite the original authors as listed below. If you use SuchTree to analyze the data, please cite the SuchTree paper.</p>"},{"location":"datasets/#hostparasite","title":"Host/Parasite","text":"<ul> <li>gopher-louse Hafner, M.S. &amp; Nadler, S.A. 1988. Phylogenetic trees support the coevolution of parasites and their hosts. Nature 332: 258-259)</li> <li>dove-louse Dale H. Clayton, Sarah E. Bush, Brad M. Goates, and Kevin P. Johnson. 2003. Host defense reinforces host\u2013parasite cospeciation. PNAS. </li> <li>sedge-smut Escudero, Marcial. 2015. Phylogenetic congruence of parasitic smut fungi (Anthracoidea, Anthracoideaceae) and their host plants (Carex, Cyperaceae): Cospeciation or host-shift speciation? American journal of botany.</li> <li>fish-worm Maarten P. M. Vanhove, Antoine Pariselle, Maarten Van Steenberge, Joost A. M. Raeymaekers, Pascal I. Habl\u00fctzel, C\u00e9line Gillardin, Bart Hellemans, Floris C. Breman, Stephan Koblm\u00fcller, Christian Sturmbauer, Jos Snoeks, Filip A. M. Volckaert &amp; Tine Huyse. 2015. Hidden biodiversity in an ancient lake: phylogenetic congruence between Lake Tanganyika tropheine cichlids and their monogenean flatworm parasites, Scientific Reports. </li> </ul>"},{"location":"datasets/#plantpollinator-visitor-interactions","title":"Plant/Pollinator (visitor) interactions","text":"<p>These were originally collected by Enrico Rezende et al. :</p> <p>Enrico L. Rezende, Jessica E. Lavabre, Paulo R. Guimar\u00e3es, Pedro Jordano &amp; Jordi Bascompte  \"Non-random coextinctions in phylogenetically structured mutualistic networks,\" Nature, 2007</p> <ul> <li>arr1  Arroyo, M.T.K., R. Primack &amp; J.J. Armesto. 1982. Community studies in pollination ecology in the high temperate Andes of central Chile. I. Pollination mechanisms and altitudinal variation. Amer. J. Bot. 69:82-97.</li> <li>arr2  Arroyo, M.T.K., R. Primack &amp; J.J. Armesto. 1982. Community studies in pollination ecology in the high temperate Andes of central Chile. I. Pollination mechanisms and altitudinal variation. Amer. J. Bot. 69:82-97.</li> <li>arr3  Arroyo, M.T.K., R. Primack &amp; J.J. Armesto. 1982. Community studies in pollination ecology in the high temperate Andes of central Chile. I. Pollination mechanisms and altitudinal variation. Amer. J. Bot. 69:82-97.</li> <li>bahe  Barrett, S. C. H., and K. Helenurm. 1987. The Reproductive-Biology of Boreal Forest Herbs.1. Breeding Systems and Pollination. Canadian Journal of Botany 65:2036-2046.</li> <li>cllo  Clements, R. E., and F. L. Long. 1923, Experimental pollination. An outline of the ecology of flowers and insects. Washington, D.C., USA, Carnegie Institute of Washington.</li> <li>dihi  Dicks, LV, Corbet, SA and Pywell, RF 2002. Compartmentalization in plant\u2013insect flower visitor webs. J. Anim. Ecol. 71: 32\u201343</li> <li>dish  Dicks, LV, Corbet, SA and Pywell, RF 2002. Compartmentalization in plant\u2013insect flower visitor webs. J. Anim. Ecol. 71: 32\u201343</li> <li>dupo  Dupont YL, Hansen DM and Olesen JM 2003 Structure of a plant-flower-visitor network in the high-altitude sub-alpine desert of Tenerife, Canary Islands. Ecography 26:301-310 </li> <li>eol   Elberling, H., and J. M. Olesen. 1999. The structure of a high latitude plant-flower visitor system: the dominance of flies. Ecography 22:314-323.</li> <li>eolz  Elberling &amp; Olesen unpubl.</li> <li>eski  Eskildsen et al. unpubl.</li> <li>herr  Herrera, J. 1988 Pollination relatioships in southern spanish mediterranean shrublands. Journal of Ecology 76: 274-287.</li> <li>hock  Hocking, B. 1968. Insect-flower associations in the high Arctic with special reference to nectar. Oikos 19:359-388.</li> <li>inpk  Inouye, D. W., and G. H. Pyke. 1988. Pollination biology in the Snowy Mountains of Australia: comparisons with montane Colorado, USA. Australian Journal of Ecology 13:191-210.</li> <li>kevn  Kevan P. G. 1970. High Arctic insect-flower relations: The interrelationships of arthropods and flowers at Lake Hazen, Ellesmere Island, Northwest Territories, Canada. Ph.D. thesis, University of Alberta, Edmonton, 399 pp.</li> <li>kt90  Kato, M., Kakutani, T., Inoue, T. and Itino, T. (1990). Insect-flower relationship in the primary beech forest of Ashu, Kyoto: An overview of the flowering phenology and the seasonal pattern of insect visits. Contrib. Biol. Lab., Kyoto, Univ., 27, 309-375.</li> <li>med1  Medan, D., N. H. Montaldo, M. Devoto, A. Mantese, V. Vasellati, and N. H. Bartoloni. 2002. Plant-pollinator relationships at two altitudes in the Andes of Mendoza, Argentina. Arctic Antarctic and Alpine Research 34:233-241.</li> <li>med2  Medan, D., N. H. Montaldo, M. Devoto, A. Mantese, V. Vasellati, and N. H. Bartoloni. 2002. Plant-pollinator relationships at two altitudes in the Andes of Mendoza, Argentina. Arctic Antarctic and Alpine Research 34:233-241.</li> <li>memm  Memmott J. 1999. The structure of a plant-pollinator food web. Ecology Letters 2:276-280.</li> <li>moma  Mosquin, T., and J. E. H. Martin. 1967. Observations on the pollination biology of plants on Melville Island, N.W.T., Canada. Canadian Field Naturalist 81:201-205.</li> <li>mott  Motten, A. F. 1982. Pollination Ecology of the Spring Wildflower Community in the Deciduous Forests of Piedmont North Carolina. Doctoral Dissertation thesis, Duke University, Duhram, North Carolina, USA; Motten, A. F. 1986. Pollination ecology of the spring wildflower community of a temperate deciduous forest. Ecological Monographs 56:21-42.</li> <li>mull  McMullen 1993</li> <li>oflo  Olesen unpubl.</li> <li>ofst  Olesen unpubl.</li> <li>olau  Olesen unpubl.</li> <li>olle  Ollerton, J., S. D. Johnson, L. Cranmer, and S. Kellie. 2003. The pollination ecology of an assemblage of grassland asclepiads in South Africa. Annals of Botany 92:807-834.</li> <li>perc  Percival, M. 1974. Floral ecology of coastal scrub in sotheast Jamaica. Biotropica, 6, 104-129.</li> <li>prap  Primack, R.B. 1983. Insect pollination in the New Zealand mountain flora. New Zealand J. Bot. 21, 317-333, AB.</li> <li>prca  Primack, R.B. 1983. Insect pollination in the New Zealand mountain flora. New Zealand J. Bot. 21, 317-333. Cass</li> <li>prcg  Primack, R.B. 1983. Insect pollination in the New Zealand mountain flora. New Zealand J. Bot. 21, 317-333. Craigieb.</li> <li>ptnd  Petanidou, T. 1991. Pollination ecology in a phryganic ecosystem. Unp. PhD. Thesis, Aristotelian University, Thessaloniki.</li> <li>rabr  Ramirez, N., and Y. Brito. 1992. Pollination Biology in a Palm Swamp Community in the Venezuelan Central Plains. Botanical Journal of the Linnean Society 110:277-302.</li> <li>rmrz  Ramirez, N. 1989. Biolog\u00eda de polinizaci\u00f3n en una comunidad arbustiva tropical de la alta Guyana Venezolana. Biotropica 21, 319-330.</li> <li>schm  Schemske, D. W., M. F. Willson, M. N. Melampy, L. J. Miller, L. Verner, K. M. Schemske, and L. B. Best. 1978. Flowering Ecology of Some Spring Woodland Herbs. Ecology 59:351-366.</li> <li>smal  Small, E. 1976. Insect pollinators of the Mer Bleue peat bog of Ottawa. Canadian Field Naturalist 90:22-28. </li> <li>smra  Smith-Ram\u00edrez C., P. Martinez, M. Nu\u00f1ez, C. Gonz\u00e1lez and J. J. Armesto 2005 Diversity, flower visitation frequency and generalism of pollinators in temperate rain forests of Chilo\u00e9 Island,Chile. Botanical Journal of the Linnean Society, 2005, 147, 399\u2013416.</li> </ul>"},{"location":"datasets/#frugivory-interactions","title":"Frugivory interactions","text":"<ul> <li>bair  Baird, J.W. 1980. The selection and use of fruit by birds in an eastern forest. Wilson Bulletin 92: 63-73.</li> <li>beeh  Beehler, B. 1983. Frugivory and polygamy in birds of paradise. Auk, 100: 1-12.</li> <li>cacg  Carlo et al. 2003. Avian fruit preferences across a Puerto Rican forested landscape: pattern consistency and implications for seed removal. Oecologia 134: 119-131</li> <li>caci  Carlo et al. 2003. Avian fruit preferences across a Puerto Rican forested landscape: pattern consistency and implications for seed removal. Oecologia 134: 119-131</li> <li>caco  Carlo et al. 2003. Avian fruit preferences across a Puerto Rican forested landscape: pattern consistency and implications for seed removal. Oecologia 134: 119-131</li> <li>cafr  Carlo et al. 2003. Avian fruit preferences across a Puerto Rican forested landscape: pattern consistency and implications for seed removal. Oecologia 134: 119-131</li> <li>crom  Crome, F.H.J. 1975. The ecology of fruit pigeons in tropical Northern Queensland. Australian Journal of Wildlife Research, 2: 155-185.</li> <li>fros  Frost, P.G.H. 1980. Fruit-frugivore interactions in a South African coastal dune forest. Pages 1179-1184 in: R. Noring (ed.). Acta XVII Congresus Internationalis Ornithologici, Deutsches Ornithologische Gessenshaft, Berlin.</li> <li>gen1  Galetti, M., Pizo, M.A. 1996. Fruit eating birds in a forest fragment in southeastern Brazil. Ararajuba, Revista Brasileira de Ornitologia, 4: 71-79.</li> <li>gen2  Galetti, M., Pizo, M.A. 1996. Fruit eating birds in a forest fragment in southeastern Brazil. Ararajuba, Revista Brasileira de Ornitologia, 4: 71-79.</li> <li>hamm  Hammann, A. &amp; Curio, B. 1999. Interactions among frugivores and fleshy fruit trees in a Philippine submontane rainforest</li> <li>hrat  Jordano P. 1985. El ciclo anual de los paseriformes frug\u00edvoros en el matorral mediterr\u00e1neo del sur de Espa\u00f1a: importancia de su invernada y variaciones interanuales. Ardeola, 32, 69-94.</li> <li>kant  Kantak, G.E. 1979. Observations on some fruit-eating birds in Mexico. Auk, 96: 183-186.</li> <li>lamb  Lambert F. 1989. Fig-eating by birds in a Malaysian lowland rain forest. J. Trop. Ecol., 5, 401-412.</li> <li>lope  Tutin, C.E.G., Ham, R.M., White, L.J.T., Harrison, M.J.S. 1997. The primate community of the Lop\u00e9 Reserve, Gabon: diets, responses to fruit scarcity, and effects on biomass. American Journal of Primatology, 42: 1-24.</li> <li>mack  Mack, AL and Wright, DD. 1996. Notes on occurrence and feeding of birds at Crater Mountain Biological Research Station, Papua New Guinea. Emu 96: 89-101. </li> <li>mont  Wheelwright, N.T., Haber, W.A., Murray, K.G., Guindon, C. 1984. Tropical fruit-eating birds and their food plants: a survey of a Costa Rican lower montane forest. Biotropica, 16: 173-192.</li> <li>ncor  P. Jordano, unpubl.</li> <li>nnog  P. Jordano, unpubl.</li> <li>sapf  Noma, N. 1997. Annual fluctuations of sapfruits production and synchronization within and inter species in a warm temperate forest on Yakushima Island, Japan. Tropics, 6: 441-449.</li> <li>snow  Snow, B.K., Snow, D.W. 1971. The feeding ecology of tanagers and honeycreepers in Trinidad. Auk, 88: 291-322.</li> <li>wes   Silva, W.R., P. De Marco, E. Hasui, and V.S.M. Gomes, 2002. Patterns of fruit-frugivores interactions in two Atlantic Forest bird communities of South-eastern Brazil: implications for conservation. Pp. 423-435. In: D.J. Levey, W.R. Silva and M. Galetti (eds.) Seed dispersal and frugivory: ecology, evolution and conservation. Wallinford: CAB International.</li> <li>wyth  Snow B.K. &amp; Snow D.W. 1988. Birds and berries, Calton, England.</li> </ul>"},{"location":"paper/","title":"Summary","text":"<p>Python has several packages for working with phylogenetic trees, each focused on somewhat different aspects of the field. Some of the more active projects include :</p> <ul> <li><code>DendroPy</code>, a multi-purpose package for reading, writing, manipulating, simulating and analyzing phylogenetic trees in Python [@dendropy]</li> <li><code>ete3</code>, a package for analysis and visualization of phylogenetic trees with Python or command line tools [@ete3]</li> <li><code>Pylogeny</code>, an analytical tool for reshaping and scoring trees with GPU support via the <code>BEAGLE</code> library [@phylogeny]</li> <li>The <code>Bio.Phylo</code> subpackage in biopython collects useful tools for working with common (and not so common) file formats in phylogenetics, along with utilities for analysis and visualization [@biophylo]</li> <li>The <code>skbio.tree</code> module in <code>scikit-bio</code> is a base class for phylogenetic trees providing analytical and file processing functions for working with phylogenetic trees [@skbio]</li> </ul> <p>Each of these packages allow trees to be manipulated, edited and reshaped. To make this possible, they must strike a balance between raw performance and flexibility, and most prioritize flexibility and a rich set of features. This is desireable for most use cases, but computational scaling challenges arise when using these packages to work with very large trees. Trees representing microbial communities may contain tens of thousands to tens of millions of taxa, depending on the community diversity and the survey methodology. </p> <p><code>SuchTree</code> is designed purely as a backend for analysis of large trees. Significant advantages in memory layout, parallelism and speed are achieved by sacrificing the ability to manipulate, edit or reshape trees (these capabilities exist in other packages). It scales to millions of taxa, and the key algorithms and data structures permit concurrent threads without locks. </p> <p></p> <p>Figure 1 : Two phylogenetic trees of 54,327 taxa were constructed using different methods (approximate maximum likelihood using <code>FastTree</code> [@price2009fasttree,@price2010fasttree] and the <code>neighbor joining</code> agglomerative clustering method). To explore the different topologies of the trees, pairs of taxa were chosen at random and the patristic distance between each pair was computed through each of the two trees. This plot shows 1,000,000 random pairs sampled from 1,475,684,301 possible pairs (0.07%). The two million distances calculations required about 12.5 seconds using a single thread.</p> <p><code>SuchTree</code> supports co-phylogenies, with functions for efficiently extracting graphs and subgraphs for network analysis, and has native support for <code>igraph</code> and <code>networkx</code>.</p> <p>In addition to the software itself, the repository includes a collection of 51 curated co-phylogenies gathered from the literature grouped into three categories by the type of ecology (frugivory, parasitism and pollination), and two collections of simulated co-phylogenies grouped by the type of simulation (independent evolution and perfect coevolution).</p>","tags":["phylogenetics","trees","microbiome","ecology","Python"]},{"location":"paper/#references","title":"References","text":"<p>BibTeX</p>","tags":["phylogenetics","trees","microbiome","ecology","Python"]},{"location":"release_notes/","title":"Release notes","text":""},{"location":"release_notes/#new-for-suchtree-v13","title":"New for SuchTree v1.3","text":"<ul> <li>Automatic URL/file/NEWICK input no longer broken</li> <li>Custom exception classes</li> <li>Improved naming conventions of methods &amp; properties</li> <li>Refactored node query methods</li> <li>Regularized naming and arguments for distance methods</li> <li>Refactored topology analysis methods</li> <li>More traversal methods</li> <li>Refactored graph theory and matrix operations</li> <li>Refactored export methods</li> <li>Stubs for backward compatibility with deprecation warnings</li> <li>Improved test coverage</li> <li>Various bug fixes</li> <li>Verified commits for GitHub, digital attestations for PiPy</li> <li>Renamed <code>master</code> to <code>main</code></li> <li>New logo, website and documentation </li> </ul>"},{"location":"release_notes/#new-for-suchtree-v12","title":"New for SuchTree v1.2","text":"<ul> <li>Quartet topology tests provided by <code>SuchTree.get_quartet_topology( a, b, c, d )</code></li> <li>Optimized, thread-safe bulk quartet topology tests provided by   <code>SuchTree.quartet_topologies( [N,4] )</code></li> <li>SuchTree now automatically detects and uses NEWICK strings as for initialization</li> </ul>"},{"location":"release_notes/#new-for-suchtree-v11","title":"New for SuchTree v1.1","text":"<ul> <li>Basic support for support values provided by <code>SuchTree.get_support( node_id )</code></li> <li>Relative evolutionary divergence (RED)</li> <li>Bipartitions</li> <li>Node generators for in-order and preorder traversal</li> <li>Summary of leaf relationships via <code>SuchTree.relationships()</code></li> </ul>"},{"location":"examples/SuchLinkedTree_examples/","title":"SuchLinkedTrees","text":"<p>In the last article, we saw how to use <code>SuchTree</code> to probe the topology of very large trees. In this article, we're going to look at the other component of the package, <code>SuchLinkedTrees</code>.</p> <p>If you are interested in studying how two groups of organisms interact (or,  rather, have interacted over evolutionary time), you will find yourself with  two trees of distinct groups of taxa that are linked by a matrix of  interaction observations. This is sometimes called a 'dueling trees' problem.</p> <p></p> <p>If the trees happen to have the same number of taxa, and the interaction  matrix happens to be a unit matrix, then you can compute the distance matrix for each of your trees and use the  Mantel test to compare them.  However, this is a pretty special case. Hommola et al. describe a method  extends the Mantel test in this paper here :</p> <ul> <li>A Permutation Test of Host\u2013Parasite Cospeciation. Molecular Biology and Evolution, Vol. 26, No. 7. (01 July 2009), pp. 1457-1468, by Kerstin Hommola, Judith E. Smith, Yang Qiu, Walter R. Gilks</li> </ul> <p>This is implemented in <code>scikit-bio</code> as <code>hommola_cospeciation</code>. Unfortunately, the version in <code>scikit-bio</code> does not scale to very large trees, and does not expose the computed distances for analysis. This is where  <code>SuchLinkedTrees</code> can help.</p> <pre><code>%config InlineBackend.figure_format='retina'\n\nfrom SuchTree import SuchTree, SuchLinkedTrees\nimport seaborn\nimport pandas\nfrom scipy.cluster.hierarchy import ClusterWarning\nfrom scipy.stats import pearsonr\n\nimport warnings\n\n#warnings.simplefilter( 'ignore', UserWarning )\n</code></pre> <p>To get started, we need to initialize two trees and a table of observations linking the taxa on the two trees.</p> <pre><code>T1 = SuchTree( '../../data/bigtrees/host.tree' )\nT2 = SuchTree( '../../data/bigtrees/guest.tree')\nLK = pandas.read_csv( '../../data/bigtrees/links.csv', index_col=0 )\n\nprint( 'host tree taxa     : %d' % T1.n_leafs )\nprint( 'guest tree taxa    : %d' % T2.n_leafs )\nprint( 'observation matrix : %d x %d' % LK.shape )\n</code></pre> <pre><code>host tree taxa     : 14\nguest tree taxa    : 103446\nobservation matrix : 14 x 103446\n</code></pre> <p>To create a <code>SuchLinkedTrees</code> instance, you need two <code>SuchTree</code>s and a pandas DataFrame, where the taxa in the first tree matches the DataFrame index, and the taxa in the second tree matches the DataFrame columns.</p> <p>This is a pretty large dataset, so it takes a bit of time to load.</p> <pre><code>%time SLT = SuchLinkedTrees( T1, T2, LK )\n</code></pre> <pre><code>CPU times: user 4min 57s, sys: 76.5 ms, total: 4min 57s\nWall time: 4min 57s\n</code></pre> <pre><code>n_links = sum(LK.apply(sum))\nprint( 'total observations : %d' % n_links )\nprint( 'observation pairs  : %d' % int( ( n_links * ( n_links - 1 ) ) / 2 ) )\n</code></pre> <pre><code>total observations : 44904\nobservation pairs  : 1008162156\n</code></pre> <p>To test for cospeciation, Hommola's method does the following :</p> <ul> <li>calculate the patristic distance between the host taxa from the two observations</li> <li>calculate the patristic distance between the guest taxa from the two observations</li> <li>calculate the Pearson's correlation of the distance measures</li> </ul> <p>Then, to calculate the significance of the correlation, it randomly permutes the observation table and recalculates the distances and correlations. A significance measure (a \\(p\\) value) is estimated based on how likely the correlation measure on unpermuted observations could belong to the set  of correlation measures on permuted observations.</p> <p>For each correlation measure, we'd have to do calculate 1,008,162,156 patristic distances through each of the two trees. To calculate the significance, we would then need to permute the observations and then repeat the process about 50 times. That's 100,816,215,600 tree traversals!</p> <p>How long would that take? In our previous example, we benchmarked 1,000,000 distance calculations at about 14 seconds on a single thread. For this dataset, one correlation measure would require about a thousand times as many lookups, so it should have a run time of about four hours. With the significance test, that would be a little more than one CPU-week. I suppose that's not impossible, but for large datasets like this, we probably don't need an exhaustive search of every possible pair of observations to get a fairly accurate correlation measure.</p> <p>So, we'ere going to use <code>SuchLinkedTrees.sample_linked_distances()</code>, which returns a representative sample of distances. It does this by filling a user-specified number of buckets (default : 64) with distances between randomly chosen observations. It stops when the standard deviation of the standard deviation of the buckets falls bellow <code>sigma</code> (default : 0.001).</p> <pre><code>%time result = SLT.sample_linked_distances( sigma=0.001, buckets=64, n=4096 )\n</code></pre> <pre><code>CPU times: user 1min 30s, sys: 15 ms, total: 1min 30s\nWall time: 1min 30s\n</code></pre> <pre><code>result\n</code></pre> <pre><code>{'TreeA': array([0.        , 0.29917303, 0.19928899, ..., 0.37183404, 0.296671  ,\n        0.23811999], shape=(3145728,)),\n 'TreeB': array([0.11925804, 0.11596022, 0.01881482, ..., 0.30879498, 0.90982425,\n        0.03588757], shape=(3145728,)),\n 'n_pairs': 1008162156.0,\n 'n_samples': 3145728,\n 'deviation_a': 0.00033290748251602054,\n 'deviation_b': 0.0009917039424180984}\n</code></pre> <pre><code>ab_r = pearsonr( result['TreeA'], result['TreeB'] )\nprint( f'sampled link pairs    : { len(result['TreeA']) }' )\nprint( f'Pearson\\'s correlation : {ab_r.statistic}' )\nprint( f'    p-value           : {ab_r.pvalue}' )\n</code></pre> <pre><code>sampled link pairs    : 3145728\nPearson's correlation : 0.01606321237653853\n    p-value           : 1.4775884174772308e-178\n</code></pre> <p>Not too bad. The algorithm went through ten iterations, placing ten blocks of 4096 pairs into each bucket before it converged on our stopping condition after testing 2,621,440 pairs (about 0.2% of the possible pairs). Note that the  \\(p\\)-value we see here is not Hommola's \\(p\\)-value -- it doesn't include any information about the topologies of the trees.</p> <p>Let's see what the distribution of sampled distances looks like.</p> <pre><code>df = pandas.DataFrame( { 'microbe tree distances' : result['TreeA'], \n                         'host tree distances'    : result['TreeB'] } )\n\nseaborn.jointplot( x='microbe tree distances',\n                   y='host tree distances',\n                   data=df, alpha=0.3, linewidth=0, s=1,\n                   marginal_kws={ 'bins': 64, 'linewidth' : 0 } )\n</code></pre> <pre><code>&lt;seaborn.axisgrid.JointGrid at 0x796a4596bfe0&gt;\n</code></pre> <p></p> <p>Well... that's... something? In this case, we are looking at the entire microbiome of a complex of 14 host species that's about 10-20 million years old. Because bacteria and archaea are older than that, we don't expect to see a meaningful pattern of coevolution at the scale of the whole microbial community.</p> <p>If we're looking for coevolution, we want to examine clades within the microbial community. This is what <code>SuchLinkedTrees</code> really designed to do.</p> <p><code>SuchLinkedTrees</code> has two functions that allow you to examine individual clades. <code>subset_a()</code> takes the node id of an internal node of the first tree (usually, the host organisms), and masks the data within the <code>SuchLinkedTrees</code> instance so that that node behaves as the root. <code>subset_b()</code> does the same for the second tree  (usually, the guest organisms).</p> <pre><code>print( f'subset A leaves : {SLT.subset_a_size}\\nsubset B leaves : {SLT.subset_b_size}' )\n</code></pre> <pre><code>subset A leaves : 14\nsubset B leaves : 103446\n</code></pre> <p>The observations are also masked so that distance calculations are constrained to within that clade. The masking operation is extremely efficient, even for very large datasets.</p> <pre><code>SLT.subset_b(121)\nprint( f'subset B leafs : {SLT.subset_b_size}' )\nSLT.subset_b_leafs\n</code></pre> <pre><code>subset B leafs : 63\n\n\n\n\n\narray([122, 124,   6,   4,   0,   2,  18, 118, 120,   8,  14,  16,  10,\n        12,  32,  34, 116,  26,  28,  30,  36,  86, 102, 104, 110, 112,\n       114,  24,  38,  40,  84,  88,  90,  92,  94, 100, 106, 108,  20,\n        22,  42,  44,  78,  96,  98,  76,  80,  82,  52,  70,  46,  72,\n        74,  48,  50,  54,  56,  58,  60,  62,  64,  66,  68])\n</code></pre> <p>OK, that's neat. But what if we want to get back to the un-subsetted dataset? For this, just pass in the root node for each tree.</p> <pre><code>print( f'subset A : {SLT.subset_a_size} leaves, subset B : {SLT.subset_b_size} leaves' )\nprint( 'resetting root subsets...' )\n\nSLT.subset_a( SLT.TreeA.root_node )\nSLT.subset_b( SLT.TreeB.root_node )\n\nprint( f'subset A : {SLT.subset_a_size} leaves, subset B : {SLT.subset_b_size} leaves' )\n</code></pre> <pre><code>subset A : 14 leaves, subset B : 63 leaves\nresetting root subsets...\nsubset A : 14 leaves, subset B : 103446 leaves\n</code></pre> <p>So, all we need to do is iterate over the internal nodes of the microbe tree (which we can get from <code>SuchTree</code>'s <code>get_internal_nodes()</code> function), subset the guest tree to that node, and apply Hommola's algorithm to the masked  <code>SuchLinkedTrees</code> instance.</p> <p>I'm going to put some simple constrains based on clade size. You could also use the average or total tree depth for each clade. It takes about an hour to finish all 103,445 clades, so let's look at a random sample of 10,000 of them.</p> <pre><code>from pyprind import ProgBar\n\nwarnings.simplefilter( 'ignore', RuntimeWarning )\n\nN = len( T2.get_internal_nodes() )\nprogbar = ProgBar( N, title='Chugging through microbime data...' )\n\ndata = []\nfor n,nodeid in enumerate( T2.get_internal_nodes() ) :\n\n    SLT.subset_b( nodeid )\n    progbar.update()\n    if SLT.subset_b_size &lt; 10 :\n        continue\n    if SLT.subset_n_links &lt; 10 :\n        continue\n    if SLT.subset_n_links &gt; 2500 :\n        continue\n\n    d = { 'name'    : 'clade_' + str(nodeid),\n          'n_links' : SLT.subset_n_links,\n          'n_leafs' : SLT.subset_b_size }\n\n    ld = SLT.linked_distances()\n\n    d['r'], d['p'] = pearsonr( ld['TreeA'], ld['TreeB'] ) \n\n    data.append( d )\n\ndata = pandas.DataFrame( data ).dropna()\n</code></pre> <pre><code>Chugging through microbime data...\n0% [##############################] 100% | ETA: 00:00:00\nTotal time elapsed: 06:39:01\n</code></pre> <p>Let's see what we've got!</p> <pre><code>data.head()\n</code></pre> name n_links n_leafs r p 0 clade_125 46 105 -0.113734 2.459121e-04 1 clade_159421 123 319 -0.037933 1.014772e-03 2 clade_121 18 63 -0.138239 8.836506e-02 3 clade_127 28 42 -0.125883 1.432212e-02 4 clade_158329 87 242 -0.085288 1.748205e-07 <pre><code>seaborn.jointplot( x='n_leafs', y='r', \n                   data=data, alpha=0.3, linewidth=0, s=1,\n                   marginal_kws={ 'bins': 64, 'linewidth' : 0 } )\n</code></pre> <pre><code>&lt;seaborn.axisgrid.JointGrid at 0x796a45b7a330&gt;\n</code></pre> <p></p> <p>Are there any clades that are big enough to to be interesting that show a significant correlation above 0.6?</p> <pre><code>data.loc[ ( data.r &gt; 0.6      ) &amp;\n          ( data.n_leafs &gt; 10 ) &amp;\n          ( data.n_links &gt; 15 ) &amp;\n          ( data.p &lt; 0.01     ) ]\n</code></pre> name n_links n_leafs r p 7792 clade_26971 22 108 0.681951 5.982235e-33 7871 clade_27163 22 103 0.681951 5.982235e-33 7955 clade_27145 20 96 0.680072 3.844922e-27 8042 clade_27061 17 87 0.676366 1.621913e-19 <p>Cool. Let's go back and look at these in more detail.</p> <pre><code>SLT.subset_b( 26971 )\n\nld = SLT.linked_distances()\n\ng = seaborn.jointplot( x=ld['TreeA'], y=ld['TreeB'], \n                       alpha=0.3, linewidth=1, s=18,\n                       marginal_kws={ 'bins': 64, 'linewidth' : 0 } )\n\ng.ax_joint.set_xlabel( 'Host tree distances' )\ng.ax_joint.set_ylabel( 'Guest tree distances' )\n\nprint( f'subset A : {SLT.subset_a_size} leaves, subset B : {SLT.subset_b_size} leaves' )\n</code></pre> <pre><code>subset A : 14 leaves, subset B : 108 leaves\n</code></pre> <p></p> <p>Eh. It's clear enough why this this clade gets a high correlation score, but  it's not actually very interesting. This is the problem with correlation  measures -- they don't test that the data obeys their assumptions. In this  case, we're using Pierson's \\(r\\), which assumes that the data from the two  sources is normally distributed, which this clearly is not. If you haven't  seen this before, check out Anscombe's quartet; the gist of his argument is that it's not a good idea to apply any statistic without examining the data graphically.</p> <p>So, let's do that, and have a look at the trees. Unfortunately, <code>toytree</code> doesn't have a straightforward way of plotting co-phylogenies yet, so this  will require some help from <code>dendropy</code> and a trip to... R. Sorry about that.</p> <pre><code>from dendropy import Tree\nfrom tempfile import NamedTemporaryFile\n\ntmpfile1 = NamedTemporaryFile()\ntmpfile2 = NamedTemporaryFile()\n\n# invert the taxa : node_id map\n# FIXME : I need a better interface for this, suggestions welcome\n\nsfeal = dict( zip( SLT.TreeB.leafs.values(), SLT.TreeB.leafs.keys() ) )\n\nsubset_taxa = [ sfeal[i] for i in SLT.subset_b_leafs ]\n\nguest_tree = Tree.get_from_path( 'data/bigtrees/guest.tree',\n                                 schema='newick',\n                                 preserve_underscores=True ) # Newick is the worst\n\nsubset_tree = guest_tree.extract_tree_with_taxa_labels( subset_taxa )\nsubset_tree.write_to_path( tmpfile1.name, schema='newick' )\n\nLK[ subset_taxa ].to_csv( tmpfile2.name )\n</code></pre> <pre><code>%load_ext rpy2.ipython\n\ncladepath = tmpfile1.name\nlinkpath = tmpfile2.name\n\noutpath = 'clade_26971.svg'\n</code></pre> <pre><code>%%R -i cladepath -i linkpath -i outpath -w 800 -h 800 -u px\n\nlibrary(\"phytools\")\nlibrary(\"igraph\")\n\ntr1 &lt;- read.tree( \"data/bigtrees/host.tree\" )\ntr2 &lt;- read.tree( cladepath )\nlinks &lt;- read.csv( linkpath, row.names=1, stringsAsFactors = F )\nim &lt;- graph_from_incidence_matrix( as.matrix( links ) )\nassoc &lt;- as_edgelist( im )\nobj &lt;- cophylo( tr1, tr2, assoc=assoc )\nsvg( outpath, width = 10, height = 12 )\nplot( obj )\n</code></pre> <pre><code>Rotating nodes to optimize matching...\nDone.\n</code></pre> <p>Now that we've gotten through the plotting hampsterdance, we can have a look at the structure of this clade and its relationship with the host organisms :</p> <p></p> <p>If we're hoping to find an example of coevolution, this is an excellent example of what we are not looking for! </p> <p>The Hommola test is not really appropriate for this application. The Hommola test is really intended for cases where you have something that looks like it might be an example of coevolution, and you would like to measure how strong the effect is. We are abusing it somewhat by asking it to distinguish coevolution from a background of other kinds of interactions, to say nothing of ignoring multiple testing effects.</p> <p>So, we'll need a more sophisticated way to test for coevolution. With <code>SuchTree</code> and <code>SuchLinkedTrees</code> handling the grunt work, we can focus on the those models.</p>"},{"location":"examples/SuchTree_examples/","title":"SuchTree","text":"<p>In this article, we'll look at some basic uses of SuchTree's <code>SuchTree</code> class :</p> <ul> <li>Loading tree data from files</li> <li>Inspecting taxa names</li> <li>Calculating patrsitic distances between pairs of taxa</li> <li>Calculating lots of patristic distances</li> <li>Loading tree data from URLs</li> <li>Sampling patristic distances from very large trees</li> <li>Parallel processing with <code>SuchTree</code></li> </ul> <p>As a bonus, we'll also cover plotting trees with <code>toytree</code>, which is especiall useful in notebook enviornemnts. To run this notebook, you will need to have the following python packages installed :</p> <ul> <li><code>SuchTree</code></li> <li><code>pandas</code></li> <li><code>cython</code></li> <li><code>scipy</code></li> <li><code>numpy</code></li> <li><code>matplotlib</code></li> <li><code>seaborn</code></li> <li><code>fastcluster</code></li> <li><code>dendropy</code></li> <li><code>toytree</code></li> <li><code>jupyter</code></li> </ul> <p>If you want to run this locally, I recommend following the Jupyter Lab documentation.</p> <p>The Internet is full of opinions about how to set up your python environment. You should find one that works for you, but this guide is as good as any to get you started. I start off by supressing some warnings that come out of scipy's hierarchal clustering function. Feel free to leave them turned on if you enjoy pendantic notifications. I'm going to assume that you are running this notebook from its locations in a local copy of the SuchTree repository for any local file paths.</p> <pre><code>%config InlineBackend.figure_format='retina'\n\nfrom SuchTree import SuchTree, SuchLinkedTrees\nfrom numpy import zeros, array\nimport seaborn\nimport pandas\nimport toytree\nimport random\nimport warnings\n\nfrom scipy.cluster.hierarchy import ClusterWarning\n\nwarnings.simplefilter( 'ignore', UserWarning )\nwarnings.simplefilter( 'ignore', FutureWarning )\n</code></pre> <p>Let's have a look at some example data. Here is a tree of cichlid fishes from my dissertation :</p> <pre><code>tree = toytree.tree( '../../data/bigtrees/host.tree' )\n\ncanvas, axes, mark = tree.draw( tree_style='d', tip_labels_align=True )\n</code></pre> Tropheus_mooriiLobochilotes_labiatusTanganicodus_irsacaeCyprichromis_coloratusHaplotaxodon_microlepisPerissodus_microlepisPlecodus_straeleniXenotilapia_flavipinnisTriglachromis_otostigmaReganochromis_calliurusTrematochromis_benthicolaLepidiolamprologus_profundicolaNeolamprologus_buescheriChalinochromis_brichardi <p>Loading tree data into <code>SuchTree</code> is pretty simple -- just give it a path to a valid Newick file.</p> <pre><code>T = SuchTree( '../../data/bigtrees/host.tree' )\n</code></pre> <p>The <code>SuchTree</code> object has a dictionary called <code>leaves</code> that maps leaf names onto their node ids. We'll make extensive use of this as we put the utility through its paces.</p> <pre><code>T.leaves\n</code></pre> <pre><code>{'Tropheus_moorii': 0,\n 'Lobochilotes_labiatus': 2,\n 'Tanganicodus_irsacae': 4,\n 'Cyprichromis_coloratus': 6,\n 'Haplotaxodon_microlepis': 8,\n 'Perissodus_microlepis': 10,\n 'Plecodus_straeleni': 12,\n 'Xenotilapia_flavipinnis': 14,\n 'Triglachromis_otostigma': 16,\n 'Reganochromis_calliurus': 18,\n 'Trematochromis_benthicola': 20,\n 'Lepidiolamprologus_profundicola': 22,\n 'Neolamprologus_buescheri': 24,\n 'Chalinochromis_brichardi': 26}\n</code></pre>"},{"location":"examples/SuchTree_examples/#calculating-distances","title":"Calculating distances","text":"<p><code>SuchTree</code> has two ways to calculate distances; one pair a time, or in batches. Batches are more efficient because it does each calculation without  the interpreter's overhead.</p> <p>Here's how to measure distances one at a time :</p> <pre><code>a = random.choice( list( T.leafs.values() ) )\nb = random.choice( list( T.leafs.values() ) )\n\nd = T.distance( a, b )\n\nprint( 'taxon 1  : %d' % a )\nprint( 'taxon 2  : %d' % b )\nprint( 'distance : %f' % d )\n</code></pre> <pre><code>taxon 1  : 12\ntaxon 2  : 26\ndistance : 0.388425\n</code></pre> <p>The <code>distance()</code> function will accept either node ids (which are integers), or taxon names (which are strings).</p> <pre><code>a = random.choice( list( T.leafs.keys() ) )\nb = random.choice( list( T.leafs.keys() ) )\n\nd = T.distance( a, b )\n\nprint( 'taxon 1  : %s' % a )\nprint( 'taxon 2  : %s' % b )\nprint( 'distance : %f' % d )\n</code></pre> <pre><code>taxon 1  : Reganochromis_calliurus\ntaxon 2  : Haplotaxodon_microlepis\ndistance : 0.270743\n</code></pre> <p>You can loop over all of the distances one at a time to construct a distance matrix...</p> <pre><code>D1 = zeros( ( len(T.leaves),len(T.leaves) ) )\nfor i,a in enumerate(  T.leafs.values() ) :\n    for j,b in enumerate( T.leafs.values() ) :\n        D1[i,j] = T.distance( a, b )\n</code></pre> <p>Let's look at the distance matrix using a nice <code>seaborn</code> clustermap plot.</p> <p>It's worth noting that <code>seaborn</code> is using scipy's <code>cluster.hierarchy</code> functions to build those dendrograms from the distance matrix. They aren't going to have exactly the same topology as the input tree, which was build with RAxML.</p> <pre><code>df = pandas.DataFrame( D1, index=[ i.replace('_',' ') for i in T.leaves.keys() ] )\nseaborn.clustermap( df, xticklabels=False, cmap='viridis', figsize=(6,4) )\n</code></pre> <pre><code>&lt;seaborn.matrix.ClusterGrid at 0x70655aabb4d0&gt;\n</code></pre> <p></p> <p>To calculate the distances in a batch, we can use the <code>distances()</code> function, which takes an \\(n \\times 2\\) array of node ids (make sure your array is representing them as integers).</p> <pre><code>D2_list = []\nfor i,a in enumerate(T.leaves.values()) :\n    for j,b in enumerate( T.leaves.values() ) :\n        D2_list.append( ( a, b ) )\nD2_array = array( D2_list )\n\nprint( D2_array.shape )\nprint( D2_array[:5] )\n</code></pre> <pre><code>(196, 2)\n[[0 0]\n [0 2]\n [0 4]\n [0 6]\n [0 8]]\n</code></pre> <pre><code>D2 = T.distances( D2_array )\n\nD2 = D2.reshape( ( len(T.leafs), len(T.leafs) ) )\n</code></pre> <p>We should get the same distance matrix and clustermap as before.</p> <pre><code>df = pandas.DataFrame( D2, index=[ i.replace('_',' ') for i in T.leaves.keys() ] )\nseaborn.clustermap( df, xticklabels=False, cmap='viridis', figsize=(6,4) )\n</code></pre> <pre><code>&lt;seaborn.matrix.ClusterGrid at 0x70655a702db0&gt;\n</code></pre> <p></p> <p>If you want to use taxon names instead, <code>distances_by_name()</code> accepts an \\(n \\times 2\\) list of tuples of taxon names, and looks up the node ids for you.</p>"},{"location":"examples/SuchTree_examples/#loading-data-from-urls","title":"Loading data from URLs","text":"<p>SuchTree can also import data from the internets. Here is the distance matrix for  the penguins, from the Global Phylogeny of Birds.</p> <pre><code>T3 = SuchTree( 'https://data.vertlife.org/birdtree/PatchClade/Stage2/set10/Spheniscidae.tre' )\n\nD3_list = []\nfor i,a in enumerate(T3.leafs.values()) :\n    for j,b in enumerate( T3.leafs.values() ) :\n        D3_list.append( ( a, b ) )\nD3_array = array( D3_list )\nD3 = T3.distances( D3_array )\nD3 = D3.reshape( ( len(T3.leafs), len(T3.leafs) ) )\n\ndf = pandas.DataFrame( D3, index=[ i.replace('_',' ') for i in T3.leafs.keys() ] )\nseaborn.clustermap( df, xticklabels=False, cmap='viridis', figsize=(6,4) )\n</code></pre> <pre><code>&lt;seaborn.matrix.ClusterGrid at 0x70654b07d370&gt;\n</code></pre> <p></p>"},{"location":"examples/SuchTree_examples/#comparing-the-topologies-of-two-large-trees","title":"Comparing the topologies of two large trees","text":"<p>So far, we haven't done anything you couldn't do with other phylogenetics packages.  <code>SuchTree</code> really shines when you have to do a lot of distance calculations on very large trees.</p> <p>Here, we use <code>SuchTree</code> to compare the topology of a two trees containing the taxa but constructed with different methods (<code>FastTree</code> and  <code>neighbor joining</code>). One million random pairs are  sampled from each tree, and the distances compared.</p> <pre><code>T1 = SuchTree( 'https://raw.githubusercontent.com/ryneches/SuchTree/refs/heads/main/data/bigtrees/ml.tree' )\nT2 = SuchTree( 'https://raw.githubusercontent.com/ryneches/SuchTree/refs/heads/main/data/bigtrees/nj.tree' )\n\nprint( 'nodes : %d, leafs : %d' % ( T1.length, len(T1.leafs) ) )\nprint( 'nodes : %d, leafs : %d' % ( T2.length, len(T2.leafs) ) )\n</code></pre> <pre><code>nodes : 108653, leafs : 54327\nnodes : 108653, leafs : 54327\n</code></pre> <pre><code>N = 1000000\n\nv = list( T1.leafs.keys() )\n\npairs = []\nfor i in range(N) :\n    pairs.append( ( random.choice( v ), random.choice( v ) ) )\n\n%time D1, D2 = T1.distances_by_name( pairs ), T2.distances_by_name( pairs )\n</code></pre> <pre><code>CPU times: user 34.4 s, sys: 142 ms, total: 34.6 s\nWall time: 34.4 s\n</code></pre> <p>The <code>distances()</code> function, which uses node ids rather than taxa names, would be a little bit faster. However, because the trees have different topologies, the taxa have different node ids in each tree. <code>SuchTree</code>'s <code>distances_by_name()</code> function untangles the leaf name to leaf node id mappings for you.</p> <pre><code>df = pandas.DataFrame( { 'ML' : D1, 'neighbor joining' : D2 } )\n\ng = seaborn.jointplot( x='ML', y='neighbor joining', data=df,\n                       alpha=0.3, linewidth=0, s=1,\n                       marginal_kws={ 'bins': 64, 'linewidth' : 0 } )\n\ng.ax_joint.set_xticks( [ 0, 0.5, 1.0, 1.5, 2.0 ] )\n</code></pre> <pre><code>[&lt;matplotlib.axis.XTick at 0x70654bdfad50&gt;,\n &lt;matplotlib.axis.XTick at 0x70654bc6aae0&gt;,\n &lt;matplotlib.axis.XTick at 0x70654bc6b530&gt;,\n &lt;matplotlib.axis.XTick at 0x70654bc6b3b0&gt;,\n &lt;matplotlib.axis.XTick at 0x70654bc7e2a0&gt;]\n</code></pre> <p></p> <pre><code>from scipy.stats import spearmanr, kendalltau, pearsonr\n\nprint( 'Spearman\\'s rs : %0.3f' % spearmanr(  D1, D2 )[0] )\nprint( 'Kendall\\'s tau : %0.3f' % kendalltau( D1, D2 )[0] )\nprint( 'Pearson\\'s r   : %0.3f' % pearsonr(   D1, D2 )[0] )\n</code></pre> <pre><code>Spearman's rs : 0.961\nKendall's tau : 0.824\nPearson's r   : 0.969\n</code></pre>"},{"location":"examples/SuchTree_examples/#parallel-processing-with-suchtree","title":"Parallel processing with SuchTree","text":"<p>Another advantage of <code>SuchTree</code>'s support for performing batches of distance  calculations is that these calculations can run outside of Python's  global interpreter lock. This makes it possible to parallelize with Python's <code>Threads</code> or <code>multiprocessing</code> libraries. On  most Unix-like operating systems, <code>multiprocessing.Pool</code> uses a copy-on-write scheme for data shared by jobs. Internally, SuchTree stores tree topology data as an immutable block of memory, so no copying will take place.</p> <p>For better or worse, Python gives users a lot of different strategies for parallel processing. SuchTree is designed to work seamlessly with all of them.</p> Approach Parallelism Memory Overhead Best for Threading No (GIL) Shared Low I/O bound ProcessPoolExecutor Yes Copied High (pickle) Small data Pool with fork Yes Shared (CoW) Minimal Immutable data Pool with spawn Yes Copied High (pickle) Windows <p><code>SuchTree</code> intentionally does not allow the user to alter trees once they are created, and so distance calculations are always thread safe. This makes it possible to use only  one instance of a tree for all threads (or processes or subinterpreters or whatever parallel processing scheme you choose). This gives you best chance of keeping the data within the CPU's L3 cache for maximum performance.</p> <p>First, let's create a Cython function that calls <code>SuchTree</code> outside of the GIL.</p> <pre><code>%load_ext Cython\n</code></pre> <pre><code>%%cython\nimport cython\nfrom libc.math cimport sqrt\n\ndef correlation(double[:] x, double[:] y) :\n    if x.shape[0] != y.shape[0] :\n        raise ValueError( 'Arrays must have the same length' )\n    if x.shape[0] &lt; 2 :\n        raise ValueError( 'Arrays must have at least 2 elements' )\n    return _correlation( x, y )\n\n@cython.boundscheck(False)\n@cython.wraparound(False)\n@cython.cdivision(True)\ncdef double _correlation( double[:] x, double[:] y ) nogil :\n    cdef int n = x.shape[0]\n    cdef int i\n    cdef double r = 0.0\n    cdef double xbar = 0.0\n    cdef double ybar = 0.0\n    cdef double sx = 0.0\n    cdef double sy = 0.0\n    cdef double dx, dy\n\n    # Compute means\n    for i in range(n):\n        xbar += x[i]\n        ybar += y[i]\n    xbar /= n\n    ybar /= n\n\n    # Compute standard deviations and correlation in one pass\n    for i in range(n):\n        dx = x[i] - xbar\n        dy = y[i] - ybar\n        sx += dx * dx\n        sy += dy * dy\n        r += dx * dy\n\n    sx = sqrt(sx)\n    sy = sqrt(sy)\n\n    # Handle zero variance case\n    if sx == 0.0 or sy == 0.0:\n        return 0.0\n\n    return r / (sx * sy)\n</code></pre> <p>Next, we'll load use <code>Pool.map()</code> from Python's <code>multiprocessing</code> library to run our processes in parallel.</p> <pre><code>from multiprocessing import Pool\n\nn = 4   # number of processes\nm = 12  # number of work units\nv = list( T1.leaves.keys() )\n\n\ndef worker_task( args ) :\n    block_idx, v, T1_leafs, T2_leafs = args\n    random.seed( block_idx )  # Different seed per block\n\n    pairs = []\n    for _ in range( 100000 ) :\n        pairs.append( ( T1_leafs[ random.choice(v) ],\n                        T2_leafs[ random.choice(v) ] ) )\n\n    task = array( pairs, dtype=int )\n    D1 = T1.distances(task)\n    D2 = T2.distances(task)\n    return correlation( D1, D2 )\n\nprint( 'building work blocks...' )\nwork_items = [ (i, v, dict(T1.leaves), dict(T2.leaves) ) \n               for i in range(m) ]\n\nprint( 'processing...' )\nwith Pool( processes=n ) as pool :\n    results = pool.map( worker_task, work_items )\n\nprint( '\\nResults :' )\nfor r in results :\n    print(r)\n</code></pre> <pre><code>building work blocks...\nprocessing...\n\nResults :\n0.7835680969259644\n0.7848744370724512\n0.7844003849954652\n0.7850059312425519\n0.7828163187067951\n0.7839538411961768\n0.783997570675356\n0.7853124277733835\n0.7865262108378938\n0.7851786514073134\n0.7847794533814942\n0.7842134015490633\n</code></pre> <p>Adapting algorithms to parallel processing is a complex topic, and this is only a toy example. Hopefully it is useful, but don't take this as the final word. SuchTree is designed to sidestep many of the problems commonly encountered in parallel computing, but that doesn't mean you won't discover problems anyway!</p>"}]}